[{"title":"Chrome浏览器出现Flash已过期","url":"/2016/12/20/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%87%BA%E7%8E%B0Flash%E5%B7%B2%E8%BF%87%E6%9C%9F/","content":"强迫症犯了？\n为什么要更新的最新的Chrome呢！\n\n在我身边包括我，在使用Chrome浏览器的时候总会”不自觉”的去更新它，然后会导致Chrome提示 Adobe Flash Player 已过期，网上也有很多解决方案，来修复这个问题，但是我这个解决方案有可能是最完美的解决方案啦！\n也许你是GWF受害者\n无意中发现的细节\n\n某天，我正好更新Chrome浏览器，打开视频播放网站也是提示 Adobe Flash Player 已过期。正是在出现这种问题的情况下，我无意中使用了VPN在浏览bilibili的时候 显示 Adobe Flash Player 已过期的提示已经变成 Adobe Flash Player正在下载，等了一会尽然可以正常加载视频了！在这种情况下，我突然想到，也许并不是Chrome浏览器的错，只是国内的GWF阻止了你的Chrome访问某个服务器下载Adobe Flash Player 。\n那么如何解决呢！一般情况下 使用VPN和SS都是要去服务商去购买租用，很是不划算（如果不想花钱系列）。在这里我向大家推荐一个GitHub的开源Hosts ：如果你安装了git工具可以直接使用：\ngit clone --depth=1 https://github.com/racaljk/hosts.git\n你也可以直接访问 https://github.com/racaljk/hosts.gitdownload文件。\n然后把Hosts文件替换到：C:\\Windows\\System32\\drivers\\etc 目录下即可。\n这样既可以修复谷歌不能访问服务器下载Adobe Flash Player的问题，以后还能正常使用Google的服务。\n","categories":["教程"],"tags":["Chrome"]},{"title":"DF标志和传送指令","url":"/2017/09/21/DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4/","content":"传送命令1)movsb\n操作步骤如下：\n1.((es)*16+(di))=((ds)**16+(si))2.if (df==0)&#123; (si)=+1 (di)=+1&#125;if(df==1)&#123; (si)=+1 (di)=+1&#125;\n2)movsw\n1.((es)*16+(di))=((ds)**16+(si))2.if (df==0)&#123; (si)=+2 (di)=+2&#125;if(df==1)&#123; (si)=-2 (di)=-2&#125;\n设置DF标志：cld;DF=0 ,std;DF=1\n编程用传送命令，将data段中的第一个字符串复制到他后面的空间中\nassume cs:codedata segmentdb &#x27;Welcome to masm!&#x27;db 16 dup (0)data endscode segmentstart: mov ax,data\t   mov ds,ax\t   mov si,0\t   mov es,ax\t   mov di,16\t   mov cx,16\t   cld ;df=0正向传送\t   rep movsb\t   \t   mov ax,4c00h;\t   int 21;\t   code endsend start\n\n\n用传送指令，把F000H段中的最后16个字符复制到data段中\n\n","categories":["汇编"],"tags":["笔记","汇编"]},{"title":"IDEA设置更好的Java注释","url":"/2019/02/27/IDEA%E8%AE%BE%E7%BD%AE%E6%9B%B4%E5%A5%BD%E7%9A%84Java%E6%B3%A8%E9%87%8A/","content":"开始配置\nCtrl+Alt+S 进入Settings-&gt;Editor-&gt;Live Templates-&gt;add 1.Live Template\n\n![IDEA Live Templates](IDEA设置更好的Java注释\\IDEA Live Templates.png)\n填入 Abbreviation 和 Description 和 Template text\n/** * @Description  * @author wlwang3 * @param $param$ * @return $return$ * @date $date$ */\n\n点击 Edit variables![Edit variables](IDEA设置更好的Java注释\\Edit variables.png)\n对param填入以下配置groovyScript(&quot;def result=&#x27;&#x27;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=(i ==0 ?&#x27;&#x27; : &#x27;* @param &#x27;) + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\\\n\\\\t\\\\t &#x27; : &#x27;&#x27;)&#125;; return result&quot;, methodParameters())\n\n其他的配置看图把函数写入即可。\n然后在方法内部 输入 add-&gt;Tab键  就可以生成javadoc了。\n懒人set生成工具顺便福利一个懒人set生成工具。  generate-set.jar \n"},{"title":"Java用lambda分页List里的数据","url":"/2018/12/17/Java%E7%94%A8lambda%E5%88%86%E9%A1%B5List%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE/","content":"​    因为业务需求需要循环调用第三方接口批量获取数据，在stackoverflow上找到了一种比较好的方法，加上泛型和注释方便后期维护使用。\nimport java.util.List;import java.util.Map;import java.util.stream.IntStream;import static java.lang.Math.min;import static java.util.stream.Collectors.toMap;/** * https://stackoverflow.com/questions/29273705/how-to-paginate-a-list-of-objects-in-java-8 * 分页工具类 Map Integer是当前页数 List当前页数内容 * * @author wlwang3 * @create 2018/12/4-18:28 **/public class PaginationUtil &#123;    public static &lt;T&gt; Map&lt;Integer, List&lt;T&gt;&gt; partition(List&lt;T&gt; list, int pageSize) &#123;        return IntStream.iterate(0, i -&gt; i + pageSize)                //循环需要页面尺寸  如pageSize=10 ,它就会10 20 30 40 50的一直循环                .limit((list.size() + pageSize - 1) / pageSize)                //限制循环的次数  list的大小+页的大小  / 页的大小                .boxed()                //看实现方法 把int包装成了对象                .collect(toMap(i -&gt; i / pageSize,                        //返回结构 key当前页数   i包装对象后的Integer是当前循环的页数大小                        i -&gt; list.subList(i, min(i + pageSize, list.size()))));        //list分页 subList(取当前循环的指针,(a &lt;= b)：如果是返回当前指针+分页的大小?:如果不是则当前的指针大小到最后一个指针的数据)    &#125;&#125;\n\n\n\n","categories":["Java"],"tags":["Java","lambda"]},{"title":"Laravel 5.3 学习笔记","url":"/2016/12/28/Laravel-5-3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"关于部署在这里写部署流程，也是对自己写的东西做一个笔记。\n项目是直接部署在WampServer环境里，默认访问链接http://localhost/Laravel-BBS/public编辑器使用的PhpStorm，因为这个编辑器专门对Laravel框架做过优化…\n开始composer create-project laravel/laravel bbs --prefer-dist\n用composer包管理器，创建一个Laravel项目 命名为bbs。\ncomposer的中文文档，由于国内GFW原因，推荐使用镜像或者VPN。\nLaravel5.3目录结构\n部署数据库修改**.env**文件\nDB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=bbsDB_USERNAME=rootDB_PASSWORD=\n\n默认认证首先我们使用Laravel 5.3提供的开箱即用的认证：\nphp artisan make:auth\n\n详细教程用户登录注册→教程\n如果Login/Register视图静态资源文件出现问题请修改app.blade.php的app.js和app.css的路径。\n&lt;link href=&quot;**&#123;&#123; url(&#x27;css/app.css&#x27;) &#125;&#125;**&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;**&#123;&#123; url(&#x27;js/app.js&#x27;) &#125;&#125;**&quot;&gt;&lt;/script&gt;\n\n关于Laravel静态资源和路径获取方法：教程，到这里一个非常基础的登录注册就完成了！\n验证码扩展包Composer验证码包简介：https://packagist.org/packages/mews/captcha\n也用中文验证码包：https://packagist.org/packages/kangkang66/captcha\n安装composer require mews/captcha\n配置使用Captcha服务提供者之前还需要在config/app.php中注册服务提供者：\n&#x27;providers&#x27; =&gt; [    // ...    Mews\\Captcha\\CaptchaServiceProvider::class,]\n\n同时注册下相应门面：\n&#x27;aliases&#x27; =&gt; [    // ...    &#x27;Captcha&#x27; =&gt; Mews\\Captcha\\Facades\\Captcha::class,]\n\n如果要使用自定义的配置，还可以发布配置文件到config目录：\nphp artisan vendor:publish\n\n编辑新生成的Captcha.php\n重写默认登录注册验证方法找到：H:\\wamp64\\www\\Laravel-BBS\\app\\Http\\Controllers\\Auth\\LoginController.php进入AuthenticatesUsers找到validateLogin方法，修改验证方法代码如下：\nprotected function validateLogin(Request $request)    &#123;        $this-&gt;validate($request, [            $this-&gt;username() =&gt; &#x27;required&#x27;,            &#x27;password&#x27; =&gt; &#x27;required&#x27;,            &#x27;captcha&#x27;=&gt;&#x27;required|captcha|max:5&#x27;        ],[            &#x27;captcha.captcha&#x27;=&gt;trans(&#x27;验证码错误！&#x27;),            &#x27;captcha.required&#x27;=&gt;trans(&#x27;验证码为必须！&#x27;),        ]);    &#125;\n\n同理，也可以在注册也添加上验证码：找到H:\\wamp64\\www\\Laravel-BBS\\app\\Http\\Controllers\\Auth\\RegisterController.php修改验证：\nprotected function validator(array $data)&#123;    return Validator::make($data, [        &#x27;name&#x27; =&gt; &#x27;required|max:255&#x27;,        &#x27;email&#x27; =&gt; &#x27;required|email|max:255|unique:users&#x27;,        &#x27;password&#x27; =&gt; &#x27;required|min:6|confirmed&#x27;,        &#x27;captcha&#x27;=&gt;&#x27;required|max:5|captcha&#x27;    ],[        &#x27;captcha.captcha&#x27;=&gt;trans(&#x27;验证码错误！&#x27;),        &#x27;captcha.required&#x27;=&gt;trans(&#x27;验证码为空！&#x27;)    ]);&#125;\n对视图文件的修改\n添加验证码图片+验证\n\n&lt;div class=&quot;form-group&#123;&#123; $errors-&gt;has(&#x27;captcha&#x27;) ? &#x27; has-error&#x27; : &#x27;&#x27; &#125;&#125;&quot;&gt;    &lt;label for=&quot;text&quot; class=&quot;col-md-4 control-label&quot;&gt;验证码&lt;/label&gt;    &lt;div class=&quot;col-md-6&quot;&gt;        &lt;input id=&quot;text&quot; type=&quot;captcha&quot; class=&quot;form-control&quot; name=&quot;captcha&quot; required&gt;        &lt;br/&gt;        &lt;span class=&quot;input-group-btn&quot;&gt;            &lt;img style=&quot;&quot; src=&quot;&#123;&#123;captcha_src()&#125;&#125;&quot;                 onclick=&quot;this.src=&#x27;&#123;&#123;captcha_src()&#125;&#125;&#x27; + Math.random()&quot;&gt;        &lt;/span&gt;        @if ($errors-&gt;has(&#x27;captcha&#x27;))            &lt;span class=&quot;help-block&quot;&gt;                &lt;strong&gt;&#123;&#123; $errors-&gt;first(&#x27;captcha&#x27;) &#125;&#125;&lt;/strong&gt;            &lt;/span&gt;        @endif    &lt;/div&gt;&lt;/div&gt;\n\n安装Laravel语言包composer require &quot;overtrue/laravel-lang:~3.0&quot;\n\nLaraval 5.*完成上面的操作后，将项目文件 config/app.php 中的下一行\nIlluminate\\Translation\\TranslationServiceProvider::class,\n\n替换为：\nOvertrue\\LaravelLang\\TranslationServiceProvider::class,\n\n修改项目语言 config/app.php：\n&#x27;locale&#x27; =&gt; &#x27;zh-CN&#x27;,\n\n未完待续。。。\n","categories":["教程"],"tags":["Laravel"]},{"title":"Laravel微信公众号游戏查询","url":"/2017/05/22/Laravel%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/","content":"环境与部署基于Laravel5.4 和 easywechat 框架制作，以下说明了部署过程，框架使用，核心代码，一些问题解决方案。\n环境需求\nPHP &gt;= 5.5.9 (PHP 7 的时代了，我在开发中一直用的PHP7)\nPHP cURL 扩展\nPHP OpenSSL 扩展\nPHP fileinfo 拓展 素材管理模块需要用到（微信公众号权限不够暂时用不到）\n\n开始部署\n安装Laravel框架\n\ncomposer create-project laravel/laravel wechat --prefer-dist\n\n安装laravel-wechat框架\n\ncomposer require &quot;overtrue/wechat:~3.3&quot; -vvv\n配置\n注册服务提供者\n\n\n在目录 config/app.php下providers数组里添加：\nOvertrue\\LaravelWechat\\ServiceProvider::class,\n创建配置文件：\nphp artisan vendor:publish --provider=&quot;Overtrue\\LaravelWechat\\ServiceProvider&quot;\n修改应用根目录下的 config/wechat.php 中对应的项即可；\n\n添加外观到 config/app.php 中的 aliases 部分：\n&#x27;EasyWeChat&#x27; =&gt; Overtrue\\LaravelWechat\\Facade::class,\n\n\nServiceProvider和Facade具体用法看下面的其他其他调用SDK方法\n\n使用Laravel 5.2 以后的版本默认启用了 web 中间件，意味着 CSRF 会默认打开，有两种方案：\n\n在 CSRF 中间件里排除微信相关的路由，添加例外路由，在app\\Http\\Middleware\\VerifyCsrfToken.phpprotected $except = [     &#x27;wechat&#x27;];\n关掉 CSRF 中间件（极不推荐）\n\n路由：\nRoute::any(&#x27;/wechat&#x27;, &#x27;WechatController@serve&#x27;);\n“开发者中心” 修改 “URL（服务器配置）” 为： http://codinger.cn/wechat\n\n注意：一定是 Route::any, 因为微信服务端认证的时候是 GET, 接收用户消息时是 POST ！\n\n然后创建控制器 WechatController\nphp artisan make:controller WechatController\n\n载入第三方类库：\n在控制器目录下创建一个Tools文件夹，放入第三方类库文件夹。这里我使用的是\nPHPQuery一个爬网站的工具，写到WechatController里。\nrequire &#x27;Tools\\phpQuery\\phpQuery.php&#x27;;\n实用composer自动加载，这样我们就可以直接在控制器里使用它了use phpQuery;\n因为我要对Minecraft服务端进行获取服务器信息和在线人数，使用一个别人写好的库\ncomposer require xpaw/php-minecraft-query\n\n现在开始写WechatController控制器：\n&lt;?phpnamespace App\\Http\\Controllers;use EasyWeChat\\Message\\Text;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Log;use xPaw\\MinecraftPing;use xPaw\\MinecraftPingException;require &#x27;Tools\\phpQuery\\phpQuery.php&#x27;;//抓取网页数据的类class WechatController extends Controller&#123;    /**     * 处理微信的请求消息     *     * @return string     */    public function serve()    &#123;        #  Log::info(&#x27;响应请求.&#x27;); # Log 为 Laravel 组件，所以它记的日志去 Laravel 日志看，而不是 EasyWeChat 日志        $weChat = app(&#x27;wechat&#x27;);//// 从项目实例中得到服务端应用实例。        $weChat-&gt;server-&gt;setMessageHandler(function($message)&#123;//使用 setMessageHandler(callable $callback) 来设置消息处理函数            switch ($message-&gt;MsgType)&#123;//检查消息类型                case &#x27;event&#x27;:                    if ($message-&gt;Event == &#x27;subscribe&#x27;)&#123;                        $text = new Text([                            &#x27;content&#x27;=&gt;&quot;感谢您关注一言查询机器人\\n例:正版玩家Player 查询Minecraft正版玩家\\n例:服务器mc.Decraft.cc(默认端口25565) 查询游戏服务器\\n还可以用语音来调教我XD\\n文字召唤机器人需要在前面加上&#x27;小冰&#x27;即可&quot;                        ]);                        return $text;                    &#125;                    break;                case &#x27;text&#x27;:                    return $this-&gt;pqText($message-&gt;Content); //对接受的文字内容进行住处理                    break;                case &#x27;image&#x27;:                    return &#x27;emmm,我没有对图片写相关功能，可以使用机器人查询你想要的图片 &#x27;;                    break;                case &#x27;voice&#x27;:                    return $this-&gt;pqVoice($message-&gt;Recognition); //对接受的语音消息转换文字处理                    break;                case &#x27;video&#x27;:                    return &#x27;因为管理员很懒没有写对视频的功能，如果让我添加也可以哦！&#x27;;                    break;                case &#x27;location&#x27;:                    return &#x27;因为管理员很懒没有写对坐标的功能，如果让我添加也可以哦！&#x27;;                    break;                case &#x27;link&#x27;:                    return &#x27;因为管理员很懒没有写对链接的功能，如果让我添加也可以哦！&#x27;;                    break;                // ... 其它消息                default:                    return &#x27;暂时不支持其它消息&#x27;;                    break;            &#125;        &#125;);        # Log::info(&#x27;返回请求完成&#x27;);        return $weChat-&gt;server-&gt;serve();    &#125;    public function pqText($content)&#123;//对文字进行匹配，修剪，对空格的删除         if (mb_substr($content,0,4)==&#x27;正版玩家&#x27;)&#123;            $playername = ltrim($content,&#x27;正版玩家&#x27;);            $playername = str_replace(&#x27; &#x27;,&#x27;&#x27;,$playername);            return $this-&gt;playerSearch($playername);        &#125;else if (mb_substr($content,0,3)==&#x27;服务器&#x27;)&#123;            $address = ltrim($content,&#x27;服务器&#x27;);            $address = str_replace(&#x27; &#x27;,&#x27;&#x27;,$address);            return $this-&gt;serverQuery($address);        &#125;else if(mb_substr($content,0,2)==&#x27;小冰&#x27;)&#123;            $ice = ltrim($content,&#x27;小冰&#x27;);            $ice = str_replace(&#x27; &#x27;,&#x27;&#x27;,$ice);            return $this-&gt;bot($ice);        &#125;else if($content==&#x27;一言&#x27;)&#123;            $hitokoto= $this-&gt;hitokoto();            return $hitokoto[&#x27;hitokoto&#x27;].&quot;\\n                    ——&quot;.$hitokoto[&#x27;from&#x27;];        &#125;        else&#123;//对其他文字消息进行功能性提示            $another = &quot;游戏查询功能例如下: \\n&quot;;            $another.= &quot;正版玩家Colorful_Ghost\\n&quot;;            $another.= &quot;服务器\tmc.Decraft.cc\\n&quot;;            $another.= &quot;一言\\n&quot;;            $another.= &quot;额外功能：召唤小冰\\n&quot;;            $another.= &quot;小冰蚌埠天气怎样\\n&quot;;            $another.= &quot;小冰水瓶座今日运势\\n&quot;;            $another.= &quot;小冰蚌埠天气怎样\\n&quot;;            $another.= &quot;小冰讲个笑话\\n&quot;;            $another.= &quot;小冰讲个故事\\n&quot;;            $another.= &quot;小冰成语接龙一诺千金\\n&quot;;            $another.= &quot;小冰周杰伦这个名字好不好\\n&quot;;            $another.= &quot;小冰图灵的简介\\n&quot;;            $another.= &quot;小冰图灵的图片\\n&quot;;            $another.= &quot;小冰查询快递123456789\\n&quot;;            $another.= &quot;小冰说个绕口令~\\n&quot;;            $another.= &quot;现在小冰支持语音功能啦！直接对提问翻译都可以哦！\\n&quot;;            $another.= &quot;更多功能陆续添加等你测试~\\n&quot;;            return $another;        &#125;    &#125;    public function pqVoice($content)&#123;//对语音消息的处理        return $this-&gt;bot($content);//把语音消息让机器人处理    &#125;    public function serverQuery($host,$port = 25565)&#123;//对Minecraft服务器进行查询,使用了composer第三方包xpaw/php-minecraft-query        try&#123;            $query = new MinecraftPing($host,$port);            if (!$query-&gt;Connect()) &#123;                $status = $query-&gt;Query();                $result = &quot;在线人数:&quot; . $status[&#x27;players&#x27;][&#x27;online&#x27;] . &#x27;/&#x27; . $status[&#x27;players&#x27;][&#x27;max&#x27;] . &quot;\\n服务器版本:&quot; . $status[&#x27;version&#x27;][&#x27;name&#x27;] . &quot;\\n服务器简介:&quot; . $status[&#x27;description&#x27;][&#x27;text&#x27;];                return $result;            &#125;else&#123;                return &#x27;服务器不存在，或者IP地址错误！&#x27;;            &#125;        &#125;catch (MinecraftPingException $e)&#123;            Log::info($e-&gt;getMessage());        &#125;finally&#123;           $query-&gt;Close();        &#125;    &#125;    public function playerSearch($player)&#123;//对Minecraft 正版玩家的信息查询，包括玩家用户名 ，UUID,皮肤数据        \\phpQuery::newDocumentFile(&#x27;https://mcuuid.net/?q=&#x27;.$player);//对mcuuid这个网站进行数据采集工作        if(pq(&#x27;h3:first&#x27;)-&gt;html()==&#x27;Useful Minecraft Resources&#x27;)&#123;            return &#x27;用户不存在,或者请求过多稍后再试&#x27;;        &#125;else&#123;            $playerdata[&#x27;username&#x27;] = pq(&#x27;h3:first&#x27;)-&gt;html();            $playerdata[&#x27;uuid&#x27;]  = pq(&#x27;input.form-control:last&#x27;)-&gt;attr(&#x27;value&#x27;);            $playerdata[&#x27;skin&#x27;]  = pq(&#x27;img:last&#x27;)-&gt;attr(&#x27;src&#x27;);            $result = &quot;玩家用户名:&quot;.$playerdata[&#x27;username&#x27;].&quot;\\n玩家UUID:&quot;.$playerdata[&#x27;uuid&#x27;].&quot;\\n玩家皮肤:&quot;.$playerdata[&#x27;skin&#x27;];            return $result;        &#125;    &#125;    public function hitokoto()&#123;//调用一言API,具体API调用方法参考一言API ： http://hitokoto.cn/api        $url = &#x27;http://api.hitokoto.cn/?encode=json&#x27;;        $json = file_get_contents($url);        $objArr = json_decode($json);        $hitokoto[&#x27;hitokoto&#x27;] = $objArr-&gt;hitokoto;        $hitokoto[&#x27;from&#x27;] = $objArr-&gt;from;        if ($objArr-&gt;hitokoto)&#123;            return $hitokoto;        &#125;else&#123;            return &#x27;一言数据获取失败&#x27;;        &#125;    &#125;    public function bot($content)&#123;//对图灵机器人的调用        $url = &#x27;http://www.tuling123.com/openapi/api?key=d8f68602b1e32dc211a4d85a87e12c90&amp;info=&#x27;.$content;        $json = file_get_contents($url);        $objArr = json_decode($json);        switch ($objArr-&gt;code)&#123;//机器人一些异常处理返回内容进行匹配            case 100000:                $text = new Text([&#x27;content&#x27;=&gt;$objArr-&gt;text]);                return $text;                break;            case 200000:                $text = new Text([&#x27;content&#x27;=&gt;$objArr-&gt;text.&quot;\\n&quot;.$objArr-&gt;url]);                return $text;                break;            case 40001:                $text = new Text([&#x27;content&#x27;=&gt;&#x27;小冰KEY错误，请联系管理员&#x27;]);                return $text;                break;            case 40002:                $text = new Text([&#x27;content&#x27;=&gt;&#x27;小冰没听清你说的是什么？请说明白一些~&#x27;]);                return $text;                break;            case 40004:                $text = new Text([&#x27;content&#x27;=&gt;&#x27;小冰今天累了~明天再来和我玩吧&#x27;]);                return $text;                break;            case 40007:                $text = new Text([&#x27;content&#x27;=&gt;&#x27;小冰出现了一些异常，请认真对待我！&#x27;]);                return $text;                break;            default:                $text = new Text([&#x27;content&#x27;=&gt;&quot;小冰并不想和你说话，并向你扔了一只猫！&quot;]);                return $text;                break;        &#125;    &#125;&#125;\n其他调用SDK方法可以通过容器自动注入&lt;?phpnamespace App\\Http\\Controllers;use EasyWeChat\\Foundation\\Application;class WechatController extends Controller&#123;    public function demo(Application $wechat)    &#123;        // $wechat 则为容器中 EasyWeChat\\Foundation\\Application 的实例    &#125;&#125;\n\n使用门面(facades)$wechatServer = EasyWeChat::server(); // 服务端$wechatUser = EasyWeChat::user(); // 用户服务\n\n问题解决在实际上线的项目 ，有可能会遇到各种问题，所以要开启Log日志debug，我就遇见了SSL证书问题，这里请参考：easyWechat的官方疑难解答，来解决这个问题。\n相关APIMinecraft Mojang 官方API：https://sessionserver.mojang.com/session/minecraft/profile/\n第三方Minecraft皮肤查询接口：https://crafatar.com/\n图灵机器人API： http://www.tuling123.com/\n一言API ： http://hitokoto.cn/api\n演示\n公众号：Game5Hei\n\n\n\n\n\n\n\n","categories":["教程"],"tags":["Laravel","easyWechat","Wechat"]},{"title":"Minecraft服务端卡顿问题排查分析","url":"/2020/03/14/Minecraft%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%88%86%E6%9E%90/","content":"今早无意查看我服Sponge服务端刷出大量的：\nCan&#x27;t keep up! Did the system time change, or is the server overloaded? Running 5400ms behind, skipping 108 tick(s)\n\n也就代表某个线程跑满 tick主频不够用了。\n但是得排查出具体原因，首先我们先使用htop看下CPU占用率，和主线程PID\n\n发现占用挺高…..现在用查到的PID进入arthas里面\n输入：dashboard\n\n发现服务端主线程长时间占用率还挺高。\n然后尝试几次 thread -n 2 查询占用最高的2个线程\n[arthas@307]$ thread -n 2&quot;Server thread&quot; Id=20 cpuUsage=97% RUNNABLE    at sun.reflect.Reflection.getCallerClass(Native Method)    at java.lang.Class.getClassLoader(Class.java:683)    at gregtech.common.pipelike.cable.tile.CableEnergyContainer.dispatchEnergyToNode(CableEnergyContainer.java)    at gregtech.common.pipelike.cable.tile.CableEnergyContainer.acceptEnergyFromNetwork(CableEnergyContainer.java:46)    at gregtech.api.capability.impl.EnergyContainerHandler.update(EnergyContainerHandler.java:150)    at gregtech.api.metatileentity.MetaTileEntity.update(MetaTileEntity.java:557)    at gregtech.api.metatileentity.MetaTileEntityHolder.func_73660_a(MetaTileEntityHolder.java:155)    at org.spongepowered.common.event.tracking.TrackingUtil.tickTileEntity(TrackingUtil.java:237)    at net.minecraft.world.WorldServer.updateTileEntity(WorldServer.java:4728)    at net.minecraft.world.WorldServer.redirect$onUpdateTileEntities$zlk000(WorldServer.java:4712)    at net.minecraft.world.World.func_72939_s(World.java:1838)    at net.minecraft.world.WorldServer.func_72939_s(WorldServer.java:3930)    at net.minecraft.server.MinecraftServer.func_71190_q(MinecraftServer.java:767)    at net.minecraft.server.dedicated.DedicatedServer.func_71190_q(DedicatedServer.java:397)    at net.minecraft.server.MinecraftServer.func_71217_p(MinecraftServer.java:668)    at net.minecraft.server.MinecraftServer.run(MinecraftServer.java:526)    at java.lang.Thread.run(Thread.java:748)\n\n发现格雷科技里的线缆这个功能 dispatchEnergyToNode方法 CPU使用率异常高\n然后去Github上看了GTCE的这一块代码\nhttps://github.com/GregTechCE/GregTech/blob/master/src/main/java/gregtech/api/capability/impl/EnergyContainerHandler.java:150\nhttps://github.com/GregTechCE/GregTech/blob/master/src/main/java/gregtech/common/pipelike/cable/tile/CableEnergyContainer.java\n发现metaTileEntity实体触发更新导致以上流程里面几层循环调用，消耗大…..作者这么写心宽啊\n好了我们要查一下metaTileEntity下面具体到游戏里的哪一个方块，从物理上解决….\n从上面的代码可以看出来\nat gregtech.api.metatileentity.MetaTileEntity.update(MetaTileEntity.java:557)\n\n在做更新操作看看这个更新代码是在哪里调用的\n\n这里好像是判断是否存在这个东西\n\n我们使用arthas 的 watch 看看这个实体里面有什么\nwatch gregtech.api.metatileentity.MetaTileEntity shouldUpdate &quot;params&quot; -x 3 -b\n\nparams是调方法的参数 -b是标识调用前的内容 -x 3 是对象深度3层，这个对象在第三层貌似就获取到了坐标数据\n\n我就取了一个查询耗时最长的一个实体到游戏里看看，应该是个多结构方块。\n游戏里/tppos 411 3 -478\n最后查询到罪魁祸首应该是这些方块….\n\n结果：阵列涡轮系统里的动力仓能源一直在更新导致卡服 （呕\n大概思路就是这样吧，Minecraft和区块世界相关都在主线程上，所以开MC服务器还是用尽量高主频U，另外阿里的arthas排查JVM问题超级好用！\n","categories":["Minecraft"],"tags":["Minecraft","问题排查"]},{"title":"MyBatisPlus拦截器应用记录","url":"/2021/10/22/MyBatisPlus%E6%8B%A6%E6%88%AA%E5%99%A8%E5%BA%94%E7%94%A8%E8%AE%B0%E5%BD%95/","content":"\n配置拦截器，用正则去匹配表名。\n\nimport cn.hutool.core.util.ReUtil;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.DynamicTableNameInnerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.InnerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.apache.commons.lang3.StringUtils;@Configurationpublic class MybatisPlusConfig &#123;    /***     * 使用ThreadLocal将表名传进来 线程可能不会被销毁值可能不会回收 记得手动remove     */    public static ThreadLocal&lt;String&gt; tableNameLocal = new ThreadLocal&lt;&gt;();    /**     * 配置分页     * 新的分页插件,一缓和二缓遵循mybatis的规则     * 需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题     * see &#123;&lt;https://mybatis.plus/guide/page.html&gt;&#125;     *     * @return PaginationInterceptor     */    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        // 动态表名拦截器        interceptor.addInnerInterceptor(initDynamicTableNameInnerInterceptor());        // 分页拦截器        interceptor.addInnerInterceptor(initPaginationInterceptor());        return interceptor;    &#125;    /**     * 初始化分页拦截器     */    private InnerInterceptor initPaginationInterceptor() &#123;        PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.POSTGRE_SQL);        // 单页分页条数限制，默认不受限制        paginationInnerInterceptor.setMaxLimit(-1L);        // 溢出总页数后是否进行处理        paginationInnerInterceptor.setOverflow(false);        return paginationInnerInterceptor;    &#125;    /**     * 初始化动态表名拦截器     */    private InnerInterceptor initDynamicTableNameInnerInterceptor() &#123;        DynamicTableNameInnerInterceptor dynamicTableNameInnerInterceptor = new DynamicTableNameInnerInterceptor();        dynamicTableNameInnerInterceptor.setTableNameHandler((sql, tableName) -&gt; &#123;            String replaceTabName = tableNameLocal.get();            tableNameLocal.remove();            if (StringUtils.isEmpty(replaceTabName)) &#123;                return tableName;            &#125;            //带有指定模式的sql 比如chongqing.next_**** 取得 chongqing.            if (tableName.contains(&quot;.&quot;)) &#123;                String schema = ReUtil.replaceAll(tableName, &quot;(.*)(\\\\\\\\.)(.*)&quot;, &quot;$1$2&quot;);                return schema + replaceTabName;            &#125; else &#123;                return replaceTabName;            &#125;        &#125;);        return dynamicTableNameInnerInterceptor;    &#125;&#125;\n\n\nService层实际开发在执行之前对本地线程设置表后缀  MybatisPlusConfig.tableNameLocal.set(tabSuffix); \n\n/** * @author Ghost */@Servicepublic class NextLineFlowServiceImpl        extends ServiceImpl&lt;NextLineFlowMapper, NextLineFlow&gt;        implements NextLineFlowService &#123;       @Autowired    private NextLineFlowMapper nextLineFlowMapper;    @Override    public NextLineFlow sumFlowByLineNameAndTime(List&lt;String&gt; lineNames, Date startTime, Date endTime, String tabSuffix) &#123;        MybatisPlusConfig.tableNameLocal.set(tabSuffix);        return this.query()                .select(&quot;linename&quot;, &quot;SUM(entryflow) entryflow&quot;,                        &quot;SUM(exitflow) exitflow&quot;,                        &quot;SUM(transferinflow) transferinflow&quot;,                        &quot;SUM(transferoutflow) transferoutflow&quot;,                        &quot;SUM(passengerflow) passengerflow&quot;)                .in(&quot;linename&quot;, lineNames)                .ge(&quot;starttime&quot;, startTime)                .le(&quot;endtime&quot;, endTime)                .groupBy(&quot;linename&quot;)                .one();    &#125;    @Override    public List&lt;NextLineFlow&gt; findByStartTimeGreaterThanEqualAndEndTimeLessThanEqualAndLineNameIn            (Date startTime, Date endTime, List&lt;String&gt; stationNames, String tabName) &#123;        return this.lambdaQuery()                .in(NextLineFlow::getLineName, stationNames)                .ge(NextLineFlow::getStartTime, startTime)                .le(NextLineFlow::getEndTime, endTime)                .list();    &#125;&#125;\n\n","tags":["Java","MyBatisPlus"]},{"title":"PostgreSQL 同步 Elasticsearch记录","url":"/2021/07/30/PostgreSQL-%E5%90%8C%E6%AD%A5-Elasticsearch%E8%AE%B0%E5%BD%95/","content":"elasticsearch安装使用docker-compose安装elasticsearch服务\n\n首先安装docker-compose\n创建elasticsearch文件夹并在下面编辑docker-compose.yml\n\nversion: &#x27;2.2&#x27;services:  node01:    image: docker.elastic.co/elasticsearch/elasticsearch:7.13.4    container_name: node01    environment:      - node.name=node01      - cluster.name=es-cluster      - discovery.type=single-node      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - es-data01:/usr/share/elasticsearch/data    ports:      - 9200:9200      - 9300:9300    networks:      - es-networkvolumes:  es-data01:    driver: local    driver_opts:      type: none      device: /root/elasticsearch/data      o: bind    #external: truenetworks:  es-network:    driver: bridgedocker-compose up -d\n\n数据将会持久化到/root/elasticsearch/data下。\n当前配置为单节点 ， 如果以后要添加集群也很方便参考官方文档修改便是。\n此处参考：https://quoeamaster.medium.com/deploying-elasticsearch-and-kibana-with-docker-86a4ac78d851\nlogstash安装并开启同步(CentOS 7 and JDK8)#配置好logstash的yum源*vim /etc/yum.repos.d/logstash.repo[logstash-7.x]name=Elastic repository for 7.x packagesbaseurl=https://artifacts.elastic.co/packages/7.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md#安装yum install logstash -y#replace current version &lt;https://jdbc.postgresql.org/download.html#current&gt;#安装pgsql-jdbccurl &lt;https://jdbc.postgresql.org/download/postgresql-&#123;version&#125;.jar&gt; -o /usr/share/logstash/logstash-core/lib/jars/postgresql-jdbc.jar#find config.support_escapes 修改vim /etc/logstash/logstash.ymlconfig.support_escapes: true#新建配置文件vim /etc/logstash/conf.d/&#123;config_name&#125;.conf#注意 currentSchema后面的参数指定数据源或者在statement里sql指定数据源input &#123;  jdbc &#123;     jdbc_connection_string =&gt; &quot;jdbc:postgresql://localhost:5432/db_chongqing?currentSchema=chongqing&quot;     jdbc_user =&gt; &quot;postgres&quot;     jdbc_password =&gt; &quot;password&quot;     jdbc_driver_library =&gt; &quot;/usr/share/logstash/logstash-core/lib/jars/postgresql-jdbc.jar&quot;     jdbc_driver_class =&gt; &quot;org.postgresql.Driver&quot;     statement =&gt; &quot;SELECT * from chongqing.table&quot;     jdbc_paging_enabled =&gt; &quot;true&quot;     jdbc_page_size =&gt; &quot;300&quot; &#125;&#125;output &#123;  stdout &#123; codec =&gt; &quot;json&quot; &#125;  elasticsearch &#123;    hosts =&gt; [&quot;&lt;http://localhost:9200&gt;&quot;]    index =&gt; &quot;next_oddata_15min_f&quot;    document_id =&gt; &quot;document_%&#123;id&#125;&quot;    doc_as_upsert =&gt; true &#125;&#125;#1. tmux查看跑入详情 启动/usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/&#123;config_name&#125;.conf#每天定时入库crontab -e0 7 * * * /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/next_oddata_15min_f_sync.conf &gt;&gt; ~/logstash.log*\n\n参考资料：\nhttps://medium.com/@emreceylan/how-to-sync-postgresql-data-to-elasticsearch-572af15845ad\nhttps://gist.github.com/ErikNovak/186e6021cf30db9160c673ee3145629f\nes可视化工具：https://github.com/qax-os/ElasticHD/releases\n","tags":["elasticsearch","docker-compose","logstash","PostgreSQL"]},{"title":"Python深度学习入门笔记","url":"/2019/07/25/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","content":"Numy使用笔记NumPy 数组( np.array )可以生成 N 维数组,即可以生成一维数组、二维数组、三维数组等任意维数的数组。数学上将一维数组称为向量,将二维数组称为矩阵。另外,可以将一般化之后的向量或矩阵等统称为张量 (tensor)。本书基本上将二维数组称为“矩阵”,将三维数组及三维以上的数组称为“张量”或“多维数组”。\n广播NumPy 中,形状不同的数组之间也可以进行运算。之前的例子中,在2×2 的矩阵 A 和标量 10 之间进行了乘法运算。在这个过程中,如图 1-1 所示,标量 10 被扩展成了 2 × 2 的形状,然后再与矩阵 A 进行乘法运算。这个巧妙的功能称为广播 (broadcast)。\nmatplotlib的使用笔记import numpy as npimport matplotlib.pyplot as plt# 生成数据x = np.arange(0, 6, 0.1) # 以 0.1 为单位,生成 0 到 6 的数据y = np.sin(x)# 绘制图形1.6Matplotlib17plt.plot(x, y)plt.show()\n\n感知机感知机接收多个输入信号,输出一个信号。x 1 、x 2 是输入信号,y 是 输 出 信 号,w 1 、w 2 是 权 重(w 是 weight 的 首 字 母)。图 中 的 ○ 称 为“神经元”或者“节点”。输入信号被送往神经元时,会被分别乘以固定的权重(w 1 x 1 、w 2 x 2 )。神经元会计算传送过来的信号的总和,只有当这个总和超过了某个界限值时,才会输出 1。这也称为“神经元被激活” 。这里将这个界限值称为阈值,用符号 θ 表示。\n未激活神经元\ny = 0 = (w1x1+w2x2)&lt;=θ\n激活神经元\ny = 1 = (w1x1+w2x2)&gt;θ\n权重相当于电流里所说的电阻。电阻是决定电流流动难度的参数,电阻越低,通过的电流就越大。而感知机的权重则是值越大,通过的信号就越大。不管是电阻还是权重,在控制信号流动难度(或者流动容易度)这一点上的作用都是一样的。\n偏置与权重的说明这里把−θ命名为偏置b，但是请注意，偏置和权重w1、w2的作用是不一样的。具体地说，w1和w2是控制输入信号的重要性的参数，而偏置是调整神经元被激活的容易程度（输出信号为1的程度）的参数。比如，若b为−0.1，则只要输入信号的加权总和超过0.1，神经元就会被激活。但是如果b为−20.0，则输入信号的加权总和必须超过20.0，神经元才会被激活。像这样，偏置的值决定了神经元被激活的容易程度。另外，这里我们将w1和w2称为权重，将b称为偏置，但是根据上下文，有时也会将b、w1、w2这些参数统称为权重。\n线性与非线性感知机的局限性就在于它只能表示由一条直线分割的空间。图2-8这样弯曲的曲线无法用感知机表示。另外，由图2-8这样的曲线分割而成的空间称为非线性空间，由直线分割而成的空间称为线性空间。线性、非线性这两个术语在机器学习领域很常见，可以将其想象成图2-6和图2-8所示的直线和曲线。\n感知机的局限性节讲到的感知机的局限性，严格地讲，应该是“单层感知机无法表示异或门”或者“单层感知机无法分离非线性空间”。\n实际上，与门、或门是单层感知机，而异或门是2层感知机。叠加了多层的感知机也称为多层感知机（multi-layered perceptron）。\n感知机小结• 感知机是具有输入和输出的算法。给定一个输入后，将输出一个既定的值。• 感知机将权重和偏置设定为参数。• 使用感知机可以表示与门和或门等逻辑电路。• 异或门无法通过单层感知机来表示。• 使用2层感知机可以表示异或门。• 单层感知机只能表示线性空间，而多层感知机可以表示非线性空间。• 多层感知机（在理论上）可以表示计算机。\n神经网络阶跃函数与sigmoid函数如果把这两个函数与水联系起来，则阶跃函数可以比作“竹筒敲石”A，sigmoid函数可以比作“水车”。阶跃函数就像竹筒敲石一样，只做是否传送水（0或1）两个动作，而sigmoid函数就像水车一样，根据流过来的水量相应地调整传送出去的水量。\n阶跃函数和sigmoid函数还有其他共同点，就是两者均为非线性函数。sigmoid函数是一条曲线，阶跃函数是一条像阶梯一样的折线，两者都属于非线性的函数。\nReLU函数def relu(x): return np.maximum(0, x)\n\nmaximum函数会从输入的数值中选择较大的那个值进行输出。\n矩阵的乘积的计算方法矩阵A和矩阵B的对应维度的元素个数必须保持一致。\n就是运算结果的矩阵C的形状是由矩阵A的行数和矩阵B的列数构成的。\nA是二维矩阵、B是一维数组时，也要保持对应维度的元素个数一致。\n输出层函数输出层所用的激活函数，要根据求解问题的性质决定。一般地，回归问题可以使用恒等函数，二元分类问题可以使用 sigmoid函数，多元分类问题可以使用 softmax函数。\n恒等函数恒等函数会将输入按原样输出。\nsoftmax函数在进行softmax的指数函数的运算时，加上（或者减去）某个常数并不会改变运算的结果。可以使用任何值，但是为了防止溢出，一般会使用输入信号中的最大值。\ndef softmax(a):    max = np.max(a) # 为了解决溢出问题    exp_a = np.exp(a- max)    return exp_a / np.sum(exp_a)\n\nsoftmax函数的输出是0.0到1.0之间的实数。并且，softmax函数的输出值的总和是1。输出总和为1是softmax函数的一个重要性质。正因为有了这个性质，我们才可以把softmax函数的输出解释为“概率\n机器学习的分类机器学习的问题大致可以分为分类问题和回归问题。分类问题是数据属于哪一个类别的问题。比如，区分图像中的人是男性还是女性的问题就是分类问题。而回归问题是根据某个输入预测一个（连续的）数值的问题。比如，根据一个人的图像预测这个人的体重的问题就是回归问题（类似“57.4kg”这样的预测）。\n学习与推理求解机器学习问题的步骤可以分为“学习”A 和“推理”两个阶段。首先，在学习阶段进行模型的学习B，然后，在推理阶段，用学到的模型对未知的数据进行推理（分类）。如前所述，推理阶段一般会省略输出层的 softmax函数。在输出层使用 softmax函数是因为它和神经网络的学习有关系\n"},{"title":"RabbitMQ简单使用记录","url":"/2021/06/03/RabbitMQ%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","content":"\n使用docker下载RabbitMQ\n\nhttps://www.rabbitmq.com/download.html\ndocker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management \\-e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password \\\n\n\n防火墙开放端口 ：5672、15672\n\n进入docker容器修改RabbitMQ密码或增加用户\n\n\n#找到容器iddocker ps#进入容器docker exec -it xxxxxxxxx bash#新增用户rabbitmqctl add_user Ghost password#修改新增用户权限为Adminrabbitmqctl set_user_tags Ghost administrator#确认下是否成功rabbitmqctl list_users\t\tListing users ...\t\tuser    tags\t\tGhost   [administrator]\t\tguest   [administrator]#删除原先guest账户rabbitmqctl delete_user guest\n","tags":["rabbitMQ","docker"]},{"title":"Spring Boot 统一异常处理使用记录","url":"/2021/10/22/Spring-Boot-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","content":"package cn.exrick.xboot.core.common.exception;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpStatus;import org.springframework.security.access.AccessDeniedException;import org.springframework.validation.BindException;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.bind.annotation.RestControllerAdvice;import javax.validation.ConstraintViolationException;@Slf4j@RestControllerAdvicepublic class ExceptionHandler &#123;    @ExceptionHandler(BindException.class)    @ResponseStatus(value = HttpStatus.OK)    public Result&lt;Object&gt; handleBindException(BindException e) &#123;        StringBuilder sb = new StringBuilder();        e.getFieldErrors().forEach(error -&gt; &#123;            String fieldName = error.getField();            String message = error.getDefaultMessage();            sb.append(fieldName + &quot;-&quot; + message + &quot;；&quot;);        &#125;);        String result = sb.toString();        if (result.length() &gt; 0) &#123;            result = result.substring(0, result.length() - 1);        &#125;        return new ResultUtil&lt;&gt;().setErrorMsg(500, result);    &#125;    @ExceptionHandler(MethodArgumentNotValidException.class)    @ResponseStatus(value = HttpStatus.OK)    public Result&lt;Object&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123;        StringBuilder sb = new StringBuilder();        e.getBindingResult().getFieldErrors().forEach(error -&gt; &#123;            String fieldName = error.getField();            String message = error.getDefaultMessage();            sb.append(fieldName + &quot;-&quot; + message + &quot;；&quot;);        &#125;);        String result = sb.toString();        if (result.length() &gt; 0) &#123;            result = result.substring(0, result.length() - 1);        &#125;        return new ResultUtil&lt;&gt;().setErrorMsg(500, result);    &#125;    @ExceptionHandler(ConstraintViolationException.class)    @ResponseStatus(value = HttpStatus.OK)    public Result&lt;Object&gt; handleConstraintViolationException(ConstraintViolationException e) &#123;        StringBuilder sb = new StringBuilder();        e.getConstraintViolations().forEach(error -&gt; &#123;            String fieldName = error.getPropertyPath().toString();            String message = error.getMessageTemplate();            sb.append(fieldName + &quot;-&quot; + message + &quot;；&quot;);        &#125;);        String result = sb.toString();        if (result.length() &gt; 0) &#123;            result = result.substring(0, result.length() - 1);        &#125;        return new ResultUtil&lt;&gt;().setErrorMsg(500, result);    &#125;    @ExceptionHandler(CaptchaException.class)    @ResponseStatus(value = HttpStatus.OK)    public Result&lt;Object&gt; handleCaptchaException(CaptchaException e) &#123;        String errorMsg = &quot;CaptchaException exception&quot;;        if (e != null) &#123;            errorMsg = e.getMsg();            log.warn(e.getMsg(), e);        &#125;        return new ResultUtil&lt;&gt;().setErrorMsg(500, errorMsg);    &#125;    @ExceptionHandler(AccessDeniedException.class)    @ResponseStatus(value = HttpStatus.OK)    public Result&lt;Object&gt; handleAccessDeniedException(AccessDeniedException e) &#123;        String errorMsg = &quot;AccessDeniedException exception&quot;;        if (e != null) &#123;            errorMsg = e.getMessage();            log.warn(e.getMessage(), e);        &#125;        return new ResultUtil&lt;&gt;().setErrorMsg(500, errorMsg);    &#125;    @ExceptionHandler(Exception.class)    @ResponseStatus(value = HttpStatus.OK)    public Result&lt;Object&gt; handleException(Exception e) &#123;        String errorMsg = &quot;Exception&quot;;        if (e != null) &#123;            errorMsg = e.getMessage();            log.error(e.toString(), e);        &#125;        return new ResultUtil&lt;&gt;().setErrorMsg(500, errorMsg);    &#125;&#125;\n\n上面的MethodArgumentNotValidException会拦截下面参数验证的异常\nimport io.swagger.annotations.ApiModelProperty;import lombok.Data;import javax.validation.constraints.NotNull;import java.io.Serializable;import java.util.List;@Datapublic class SearchLineFlowVo implements Serializable &#123;    @ApiModelProperty(value = &quot;综合分析(类别:断面 线路 车站)||换成客流查询(类别: 换入 换出)&quot;)    private String categoryType;    @ApiModelProperty(value = &quot;断面名称 或 线路名称&quot;)    @NotNull(message = &quot;断面名称或线路名称不能为空&quot;)    private List&lt;String&gt; categoryNames;    @ApiModelProperty(value = &quot;日期到日&quot;)    @NotBlank(message = &quot;日期不能为空&quot;)    private String dateOfDay;    @ApiModelProperty(value = &quot;颗粒度 5 15 30 60 1440&quot;)    @NotNull(message = &quot;颗粒度不能为空&quot;)    private String timeSpan;    @ApiModelProperty(value = &quot;页面大小&quot;)    @NotNull(message = &quot;页面大小不能为空&quot;)    private PageVo pageVo;    @ApiModelProperty(value = &quot;搜索范围&quot;)    @NotNull(message = &quot;搜索范围不能为空&quot;)    private SearchVo searchVo;    @ApiModelProperty(value = &quot;换入 :lineoutdir 换出 :lineindir 括弧：就是反着的:)&quot;)    private String lineInOrOut;    @ApiModelProperty(value = &quot;对比：yyyy-MM-dd(日) yyyy-MM-dd_yyyy-MM-dd(周or自选) &quot;)    private String comparisonDate;    @ApiModelProperty(value = &quot;参照：yyyy-MM-dd yyyy-MM-dd(日) yyyy-MM-dd_yyyy-MM-dd(周or自选) &quot;)    private String referenceDate;    @ApiModelProperty(value = &quot;周月年&quot;)    private String dateRange;&#125;\n\n","tags":["Spring Boot","ExceptionHandler","Spring validation"]},{"title":"Spring-Data-Elasticsearch开发记录","url":"/2021/08/22/Spring-Data-Elasticsearch%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/","content":"因为Spring-Data-Elasticsearch的这个包版本之间的封装差距蛮大的，最新版本的里面API已经弃用了好多方法，搜索引擎上现在查到的大部分资料是比较老的版本 ，已经不推荐使用。\n\n依赖引入\n\n&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;    &lt;/dependency&gt;\n\n\n在项目启动项加入注解扫repository包(Dao层)\n\n@EnableElasticsearchRepositories(&quot;com.*.*.*.repository&quot;)\n\n\n在application.yml里添加ES相关配置和Debug的日志打印\n\nspring:  data:    elasticsearch:      repositories:        enabled: true  elasticsearch:    rest:      # 要连接的ES客户端Rest Uri 多个逗号分隔      uris: &lt;http://localhost:9200&gt;logging:  level:    org.springframework.security:      - debug      - info    org.springframework.web: error    org:      springframework:        data:          elasticsearch:            core: DEBUG      apache:        http: DEBUG      elasticsearch:        client: DEBUG        WIRE: DEBUG\n\n\n在entity文件夹下创建实体类\n\n@Data@Entity@Document(indexName = &quot;report_section_flow_5min_f&quot;, replicas = 0, refreshInterval = &quot;1m&quot;)@ApiModel(value = &quot;5分钟断面数据&quot;)public class SectionFlow5Min &#123;    @Id    private Long id;    @ApiModelProperty(&quot;区间标识名&quot;)    @Field(name = &quot;identifyname&quot;)    private String identifyName;    @ApiModelProperty(&quot;开始时间&quot;)    @Field(name = &quot;starttime&quot;, format = DateFormat.date_optional_time, type = FieldType.Date)    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&quot;, timezone = &quot;GMT+8&quot;)    private Date startTime;\t\t@ApiModelProperty(&quot;结束时间&quot;)    @Field(name = &quot;endtime&quot;, format = DateFormat.date_optional_time, type = FieldType.Date)    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&quot;, timezone = &quot;GMT+8&quot;)    private Date endTime;&#125;\n\n这里要注意下时间的序列化 ，否则查询会报错。\n\n在repository下创建interface继承ElasticsearchRepository\n\npublic interface SectionFlow5MinDao extends ElasticsearchRepository&lt;SectionFlow5Min, Long&gt; &#123;    Page&lt;SectionFlow5Min&gt; findByStartTimeGreaterThanEqualAndEndTimeLessThanEqualAndSectionNameIn            (Date startTime, Date endTime, Collection&lt;String&gt; sectionNames, Pageable pageable);    List&lt;SectionFlow5Min&gt; findByStartTimeGreaterThanEqualAndEndTimeLessThanEqualAndSectionName            (Date startTime, Date endTime, String sectionName);&#125;\n\n此处findByStartTimeGreaterThanEqualAndEndTimeLessThanEqualAndSectionNameIn\n是从ES里寻找开始时间大于等于StartTime 并且小于等于EndTime 并且查找多个SectionName 。\n\n聚合查询\n\n当然遇见复杂的查询或者聚合查询ElasticsearchRepository可能就满足不了了这时候需要用\nNativeSearchQueryBuilder 去写查询语句或者用@Query注解，但是在@Query里写JSON我感觉实在太反人类了，还是NativeSearchQueryBuilder 好用，下面放代码。\nimport org.springframework.data.domain.Pageable;//ServiceImpl层实现private Map&lt;Page&lt;StationFlow5Min&gt;, Map&lt;String, Map&lt;String, ParsedSum&gt;&gt;&gt; find5MinDataByES(String startTime, String endTime,                                                                                             List&lt;String&gt; categoryNames,                                                                                             Pageable pageable) &#123;        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();        QueryBuilder qb1 = QueryBuilders.rangeQuery(&quot;starttime&quot;).from(startTime);        QueryBuilder qb2 = QueryBuilders.rangeQuery(&quot;endtime&quot;).to(endTime);        QueryBuilder qb3 = QueryBuilders.queryStringQuery(ESUtils.subStrListToStr(categoryNames)).field(&quot;stationname&quot;);        BoolQueryBuilder must = QueryBuilders.boolQuery().must(qb1).must(qb2).must(qb3);        //ES从0索引        if (pageable.getPageNumber() == 0) &#123;            SumAggregationBuilder sum1 = AggregationBuilders.sum(&quot;entryFlowSum&quot;).field(&quot;entryflow&quot;);            SumAggregationBuilder sum2 = AggregationBuilders.sum(&quot;exitFlowSum&quot;).field(&quot;exitflow&quot;);            TermsAggregationBuilder stationNameTerm = AggregationBuilders.terms(&quot;stationName&quot;).field(&quot;stationname.keyword&quot;);            stationNameTerm.subAggregation(sum1);            stationNameTerm.subAggregation(sum2);            queryBuilder.addAggregation(stationNameTerm);        &#125;        queryBuilder.withQuery(must)                .withPageable(pageable);        SearchHits&lt;StationFlow5Min&gt; search = elasticsearchOperations.search(queryBuilder.build(), StationFlow5Min.class);        Map&lt;String, Map&lt;String, ParsedSum&gt;&gt; aggBucketsInAgg = null;        if (search.getAggregations() != null) &#123;            aggBucketsInAgg = ESUtils.getAggBucketsInAgg(search.getAggregations());        &#125;        Map&lt;Page&lt;StationFlow5Min&gt;, Map&lt;String, Map&lt;String, ParsedSum&gt;&gt;&gt; result = new HashMap&lt;&gt;();        result.put(ESUtils.getPages(search, pageable), aggBucketsInAgg);        return result;    &#125;\n\npageable.getPageNumber() == 0 是业务场景可以无视， AggregationBuilders 是聚合查询封装好的方法 ，此处sum(entryflow),sum(exitflow)聚合查询出的字段命名为entryFlowSum、exitFlowSum并且把q1,q2,q3的数据查询也带出来，还有一点要注意，在使用聚合查询一定要标记查询字段为.keyword\n提高索引效率AggregationBuilders.terms(&quot;stationName&quot;).field(&quot;stationname.keyword&quot;);\n如果不加.keyword 在ES会查询报错。这里Map里返回的ParsedSum 是ES封装好的Sum后的值。（看了es的源码 ，我总感觉spring data-es过度封装了，在使用的时候比较难受）\n\nESUtil里的封装方法说明\n\n关于ESUtil里的方法，为了取数据更方便一些而封装了一下。\nimport cn.hutool.json.JSONUtil;import org.elasticsearch.search.aggregations.Aggregation;import org.elasticsearch.search.aggregations.Aggregations;import org.elasticsearch.search.aggregations.bucket.terms.Terms;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.elasticsearch.core.SearchHit;import org.springframework.data.elasticsearch.core.SearchHitSupport;import org.springframework.data.elasticsearch.core.SearchHits;import org.springframework.data.elasticsearch.core.SearchPage;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.stream.Collectors;public class ESUtils &#123;    /**     * 返回ES所封装的page     *     * @param searchHits     * @param pageable     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; SearchPage&lt;T&gt; geHitstPages(SearchHits&lt;T&gt; searchHits, Pageable pageable) &#123;        return SearchHitSupport.searchPageFor(searchHits, pageable);    &#125;    public static &lt;T&gt; List&lt;T&gt; getHitsContents(SearchPage&lt;T&gt; searchHits) &#123;        return searchHits.stream().map(SearchHit::getContent).collect(Collectors.toList());    &#125;    /**     * 把返回的数据处理成JPA里的 page     *     * @param searchHits     * @param pageable     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; Page&lt;T&gt; getPages(SearchHits&lt;T&gt; searchHits, Pageable pageable) &#123;        return geHitstPages(searchHits, pageable).map(SearchHit::getContent);    &#125;    public static &lt;T&gt; Map&lt;String, T&gt; getAggregation(Aggregations aggregations) &#123;        return aggregations.asList().stream().collect(Collectors.toMap(Aggregation::getName, i -&gt; (T) i));    &#125;    /**     * 把普通时间格式的转换成世界标准格式 （es本质存的就是JSON字符串）     *     * @param time     * @return     */    public static String timeFormatBlankReT(String time) &#123;        return time.replace(&quot; &quot;, &quot;T&quot;);    &#125;    /**     * QueryBuilders.queryStringQuery 查询多个字段需要对查询字段处理下     *     * @param ss     * @return     */    public static String subStrListToStr(List&lt;String&gt; ss) &#123;        String s = JSONUtil.toJsonStr(ss);        s = s.substring(1, s.length() - 1);        s = s.replace(&quot;,&quot;, &quot;&quot;);        return s;    &#125;    /**     * 拿取返回的聚合查询的数据 并且返回为Map结构     *     * @param aggregations     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; Map&lt;String, Map&lt;String, T&gt;&gt; getAggBucketsInAgg(Aggregations aggregations) &#123;        Map&lt;String, Map&lt;String, T&gt;&gt; results = new HashMap&lt;&gt;();        for (Aggregation aggregation : aggregations) &#123;            List&lt;? extends Terms.Bucket&gt; buckets = ((Terms) aggregation).getBuckets();            Map&lt;String, T&gt; bucketMap = new HashMap&lt;&gt;();            String groupByName = null;            for (Terms.Bucket bucket : buckets) &#123;                groupByName = bucket.getKeyAsString();                for (Aggregation bucketAggregation : bucket.getAggregations()) &#123;                    bucketMap.put(bucketAggregation.getName(), (T) bucketAggregation);                &#125;            &#125;            results.put(groupByName, bucketMap);        &#125;        return results;    &#125;&#125;\n\n\n踩坑说明\n\n最后如何定位我的查询语句是否有问题，在你写的NativeSearchQueryBuilder 变量打上断点 ，本质上他是在处理最终的JSON结构，如果你使用的是ElasticsearchRepository 可以去源码core里寻找组装语句的地方打断点，复制出来去工具里调试。\n\n在使用中参考了如下文档：\n\nhttps://www.jianshu.com/p/7d1f72ca49ba\nhttps://github.com/spring-projects/spring-data-elasticsearch/blob/main/src/main/asciidoc/reference/elasticsearch-repository-queries.adoc\nhttps://segmentfault.com/a/1190000016296983\n","tags":["elasticsearch","jpa","spring"]},{"title":"Spring boot 入门篇-新建项目","url":"/2018/03/23/Spring-boot-%E5%85%A5%E9%97%A8%E7%AF%87-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE/","content":"使用Spring initializr初始化项目　　可以直接访问http://start.spring.io Generate Spring Boot项目，生成后解压直接拖进IDE，也可以使用Spring initializr在IDEA可以直接初始化。\n\n\n填写包名和业务名\n\n\n\n确认项目路径\n\n\n\n创建完成\n\n\n","categories":["Spring boot"],"tags":["Spring boot"]},{"title":"VSCode工作区配置","url":"/2019/07/24/VSCode%E5%B7%A5%E4%BD%9C%E5%8C%BA%E9%85%8D%E7%BD%AE/","content":"个人用的比较舒服的VSCode工作区配置 ，记录下在换其他平台也能随手复制使用。\n现在VSCode已经支持配置文件和插件同步的功能了，以防万一我还是备份一下，避免重新配置浪费时间。\n&#123;  &quot;workbench.activityBar.visible&quot;: true,  &quot;workbench.colorTheme&quot;: &quot;Dark++ Regular&quot;,  &quot;workbench.iconTheme&quot;: &quot;vscode-great-icons&quot;,  &quot;workbench.startupEditor&quot;: &quot;newUntitledFile&quot;,  &quot;git.path&quot;: &quot;C:\\\\Program Files\\\\Git\\\\cmd\\\\git.exe&quot;,  &quot;files.associations&quot;: &#123;    &quot;*.vue&quot;: &quot;vue&quot;,    &quot;*.wpy&quot;: &quot;vue&quot;,    &quot;*.wxml&quot;: &quot;html&quot;,    &quot;*.wxss&quot;: &quot;css&quot;  &#125;,  &quot;git.enableSmartCommit&quot;: true,  &quot;git.autofetch&quot;: true,  &quot;emmet.triggerExpansionOnTab&quot;: true,  &quot;emmet.showAbbreviationSuggestions&quot;: true,  &quot;emmet.showExpandedAbbreviation&quot;: &quot;always&quot;,  &quot;emmet.includeLanguages&quot;: &#123;    &quot;vue-html&quot;: &quot;html&quot;,    &quot;vue&quot;: &quot;html&quot;,    &quot;wpy&quot;: &quot;html&quot;  &#125;,  //主题颜色   //&quot;workbench.colorTheme&quot;: &quot;Monokai&quot;,  &quot;git.confirmSync&quot;: false,  &quot;explorer.confirmDelete&quot;: false,  &quot;window.zoomLevel&quot;: 1,  &quot;editor.wordWrap&quot;: &quot;on&quot;,  &quot;editor.detectIndentation&quot;: false,  // 重新设定tabsize  &quot;editor.tabSize&quot;: 2,  //失去焦点后自动保存  &quot;files.autoSave&quot;: &quot;onFocusChange&quot;,  // #值设置为true时，每次保存的时候自动格式化；  &quot;editor.formatOnSave&quot;: false,  //每120行就显示一条线  &quot;editor.rulers&quot;: [],  // 在使用搜索功能时，将这些文件夹/文件排除在外  &quot;search.exclude&quot;: &#123;    &quot;**/node_modules&quot;: true,    &quot;**/bower_components&quot;: true,    &quot;**/target&quot;: true,    &quot;**/logs&quot;: true,  &#125;,  // 这些文件将不会显示在工作空间中  &quot;files.exclude&quot;: &#123;    &quot;**/.git&quot;: true,    &quot;**/.svn&quot;: true,    &quot;**/.hg&quot;: true,    &quot;**/CVS&quot;: true,    &quot;**/.DS_Store&quot;: true,    &quot;**/*.js&quot;: &#123;      &quot;when&quot;: &quot;$(basename).ts&quot; //ts编译后生成的js文件将不会显示在工作空中    &#125;,    &quot;**/node_modules&quot;: true  &#125;,  // vue设置  &quot;emmet.syntaxProfiles&quot;: &#123;    &quot;vue-html&quot;: &quot;html&quot;,    &quot;vue&quot;: &quot;html&quot;  &#125;,  // #让vue中的js按&quot;prettier&quot;格式进行格式化  &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,  &quot;vetur.format.defaultFormatter.js&quot;: &quot;prettier&quot;,  &quot;vetur.format.defaultFormatterOptions&quot;: &#123;    &quot;js-beautify-html&quot;: &#123;      // #vue组件中html代码格式化样式      &quot;wrap_attributes&quot;: &quot;force-aligned&quot;, //也可以设置为“auto”，效果会不一样      &quot;wrap_line_length&quot;: 200,      &quot;end_with_newline&quot;: false,      &quot;semi&quot;: false,      &quot;singleQuote&quot;: true    &#125;,    &quot;prettier&quot;: &#123;      &quot;semi&quot;: false,      &quot;singleQuote&quot;: true    &#125;  &#125;,  &quot;[vue]&quot;: &#123;    &quot;editor.defaultFormatter&quot;: &quot;octref.vetur&quot;  &#125;,  &quot;[javascript]&quot;: &#123;    &quot;editor.defaultFormatter&quot;: &quot;vscode.typescript-language-features&quot;  &#125;,  &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git Bash&quot;&#125;","tags":["vue","VSCode"]},{"title":"二手SAS硬盘无法识别扇区修复","url":"/2021/06/03/%E4%BA%8C%E6%89%8BSAS%E7%A1%AC%E7%9B%98%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E6%89%87%E5%8C%BA%E4%BF%AE%E5%A4%8D/","content":"最近再挖XCH，本地收了20个4T希捷SAS盘， 但是都无法正确识别与格式化。\n这里感谢阿夜帮忙排查问题和折腾成功㊗️\nhttps://www.seagate.com/jp/ja/support/software/seachest/\n下载 SeaChest Lite，和准备好直通卡。\n提取你所在系统的文件\n如：SeaChest_Format_x86_64-linux-gnu\n放入Linux下 chmod +x SeaChest_Format_x86_64-linux-gnu\n./SeaChest_Format_x86_64-linux-gnu --scanVendor   Handle       Model Number            Serial Number          FwRev     ATA      /dev/sg0     ST1000DM003-1CH162      Z1D9KP97               CC49      ATA      /dev/sg1     KINGSTON SA400S37120G   50026B7782C1ED47       03090004  SEAGATE  /dev/sg2     ST4000NM0023            Z1Z35SL5               MS0B      SEAGATE  /dev/sg3     ST4000NM0023            Z1Z3493L               MS0B      SEAGATE  /dev/sg4     ST4000NM0023            Z1Z348ME               MS0B      SEAGATE  /dev/sg5     ST4000NM0023            Z1Z3H3W3               MS0B      SEAGATE  /dev/sg6     ST4000NM0023            Z1Z3CMM7               MS0B      SEAGATE  /dev/sg7     ST4000NM0023            Z1Z3G2K4               MS0B      SEAGATE  /dev/sg8     ST4000NM0023            Z1Z35SHB               MS0B      SEAGATE  /dev/sg9     ST4000NM0023            Z1Z35SH8               MS0B\n\n从sg2-sg9都是无法识别的硬盘\n./SeaChest_Format_x86_64-linux-gnu -d /dev/sg2 -i/dev/sg2 - ST4000NM0023 - Z1Z35SL50000C4253UN7 - SCSI        Vendor ID: SEAGATE         Model Number: ST4000NM0023            Serial Number: Z1Z35SL5        PCBA Serial Number: 0000C4253UN7        Firmware Revision: MS0B        World Wide Name: 5000C50058054B57        Copyright: Copyright (c) 2013 Seagate All rights reserved         Drive Capacity (B/B): 0.00/0.00        Temperature Data:                Current Temperature (C): Not Reported                Highest Temperature (C): Not Reported                Lowest Temperature (C): Not Reported        Power On Time: Not Reported        Power On Hours: Not Reported        MaxLBA: 0        Native MaxLBA: Not Reported        Logical Sector Size (B): 0        Physical Sector Size (B): 0        Sector Alignment: 0        Rotation Rate (RPM): 7200        Form Factor: 3.5&quot;        Last DST information:                Not supported        Long Drive Self Test Time:  9 hours 5 minutes         Interface speed:                Not Reported        Annualized Workload Rate (TB/yr): Not Reported        Total Bytes Read (B): Not Reported        Total Bytes Written (B): Not Reported        Encryption Support: Not Supported        Cache Size (MiB): Not Reported        Read Look-Ahead: Not Supported        Write Cache: Not Supported        SMART Status: Unknown or Not Supported        ATA Security Information: Not Supported        Firmware Download Support: Full, Deferred        Number of Logical Units: 1        Specifications Supported:                SPC-3        Features Supported:                Protection Type 1                Protection Type 2        Adapter Information:                Vendor ID: 1000h                Product ID: 0087h                Revision: 0005h\n\n我们查看期中一个硬盘的信息 ，可以看到这个磁盘\n     Logical Sector Size (B): 0\n    Physical Sector Size (B): 0\n\n SMART Status: Unknown or Not Supported\n\n这里用了垃圾山寨虚标电源 ！供电不足会导致磁盘使用不了，换电源！\n./SeaChest_Format_x86_64-linux-gnu -d /dev/sg5 -i\n/dev/sg5 - ST4000NM0023 - Z1Z3H3W300009432XAUA - SCSI        Vendor ID: SEAGATE         Model Number: ST4000NM0023            Serial Number: Z1Z3H3W3        PCBA Serial Number: 00009432XAUA        Firmware Revision: MS0B        World Wide Name: 5000C50058547F23        Copyright: Copyright (c) 2013 Seagate All rights reserved         Drive Capacity (TB/TiB): 3.98/3.62        Temperature Data:                Current Temperature (C): 34                Highest Temperature (C): Not Reported                Lowest Temperature (C): Not Reported        Power On Time:  2 years 15 days 19 hours 9 minutes         Power On Hours: 17899.15        MaxLBA: 7648717975        Native MaxLBA: Not Reported        Logical Sector Size (B): 520        Physical Sector Size (B): 520        Sector Alignment: 0        Rotation Rate (RPM): 7200        Form Factor: 3.5&quot;        Last DST information:                DST has never been run        Long Drive Self Test Time:  9 hours 5 minutes         Interface speed:                Port 0 (Current Port)                        Max Speed (GB/s): 6.0                        Negotiated Speed (Gb/s): 6.0                Port 1                        Max Speed (GB/s): 6.0                        Negotiated Speed (Gb/s): Not Reported        Annualized Workload Rate (TB/yr): 178.54        Total Bytes Read (TB): 198.82        Total Bytes Written (TB): 166.00        Encryption Support: Not Supported        Cache Size (MiB): Not Reported        Read Look-Ahead: Not Supported        Write Cache: Disabled        SMART Status: Good        ATA Security Information: Not Supported        Firmware Download Support: Full, Segmented, Deferred        Number of Logical Units: 1        Specifications Supported:                SPC-3        Features Supported:                Protection Type 1                Protection Type 2                Application Client Logging                Self Test                EPC                Informational Exceptions [Mode 2]                Translate Address                Format Unit        Adapter Information:                Vendor ID: 1000h                Product ID: 0087h                Revision: 0005h\n\n换过电源后 依次使用-i检查8个硬盘是否通电正常，如果有不正常再次检查硬件上哪里有问题。可以看到磁盘分区是520格式\n如果没有问题就可以把 520 扇区大小转化成512 ，操作如下。\n./SeaChest_Format_x86_64-linux-gnu -d /dev/sg2 --formatUnit 512 --fastFormat 2 --confirm this-will-erase-data\n\n–formatUnit 512 （格式化512分区\n–fastFormat 2  （快速格式化不保留数据\n–confirm this-will-erase-data （擦除所有数据确认\n出现\n/dev/sg9 - ST4000NM0023 - Z1Z35SHB0000C424A81Y - SCSIFormat UnitPerforming SCSI drive format.Depending on the format request, this could take minutes to hours or days.Do not remove power or attempt other access as interrupting it may makethe drive unusable or require performing this command again!!\n\n代表正在格式化中 ，结束后一次停止硬盘 换下一批继续如上操作\n./SeaChest_PowerControl_x86_64-linux-gnu  -d /dev/sg9 --spinDown\n\n我的4T SAS硬盘 20个硬盘测试大概需要14小时，其中有一块硬盘格式化了3天，八成没戏翻车了。\n"},{"title":"使用Docker部署MySQL","url":"/2018/12/26/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2MySQL/","content":"卸载旧版本Docker（如果没有安装过跳过）$ sudo yum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-selinux \\                  docker-engine-selinux \\                  docker-engine\n\n安装Docker CE# step 1: 安装必要的一些系统工具sudo yum install -y yum-utils device-mapper-persistent-data lvm2# Step 2: 添加软件源信息 这里推荐国内阿里的镜像sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# Step 3: 更新并安装 Docker-CEsudo yum makecache fastsudo yum -y install docker-ce# Step 4: 开启Docker服务sudo service docker start\n\n\n\n获取MySQL的Docker镜像找到MySQL的镜像仓库MySQL镜像仓库：https://hub.docker.com/_/mysql\n创建MySQL容器# -p 把宿主机器的端口桥接到容器内的端口内 # -- name 指的是你的docker container name# -v 把宿主机器的文件挂载到容器内达到容器内容的数据能持久化到宿主机器上# 关于-v参数Docker Volume 可以查看这篇文章  http://dockone.io/article/128# -e 配置参数# $PWD 你持久化文件路径地址# -d --detach=false  指定容器运行于前台还是后台，默认为false   # docker run 命令常见参数参考https://blog.csdn.net/kunloz520/article/details/53839237# mysql:latest mysql镜像:版本 会指定从镜像仓库拉取5.7版本为基础的镜像后运行容器docker run -p 3306:3306 --name mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7\n\n查看Docker运行状态[root@middlehomework-no docker-mysql]# docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMESb2291bf42076        mysql:5.7           &quot;docker-entrypoint.s…&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mysql\n\n检查端口是否正常开放iptables配置：\niptables -L# 如果没有则开通端口iptables -A INPUT -p tcp --dport 3306 -j ACCEPTiptables -A OUTPUT -p tcp --sport 3306 -j ACCEPT\n\nCentOS7用户firewalld配置:\n# 查看所有打开的端口firewall-cmd --zone=public --list-ports# 如果没有3306端口则开通端口firewall-cmd --zone=public --add-port=3306/tcp --permanent\n\n意外情况Docker 容器被意外关闭# restart 重启 stop 停止 容器docker start &lt;CONTAINER ID&gt;\n\n修改MySQL密码docker stop &lt;CONTAINER ID&gt;docker rm &lt;CONTAINER ID&gt;# 因为mysql的重要数据和配置文件都已经持久化在宿主机器上，如果容器内的其他文件配置也需要持久化加-vdocker run -p 3306:3306 --name mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=你修改后的密码 -d mysql:5.7\n\n因为Docker本身是无状态容器，有状态即有多个功能不同的实例，有依赖和启动先后关系，需要做数据持久化。无状态即实例间互相不依赖，它的请求包含了响应端需求的全部信息，比较好伸缩 ，所以在Docker做数据持久化就会稍微麻烦一些。\n","categories":["Docker"],"tags":["Docker","MySQL"]},{"title":"使用crontab定时备份MySQL数据库","url":"/2019/03/11/%E4%BD%BF%E7%94%A8crontab%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDMySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"定时备份#!/bin/shmysqldump --opt -Q -uroot -ppassword --default-character-set=utf8mb4 $(datatable) &gt; /$(pwd)/$(file_name)_$(date &quot;+%Y%m%d_%H:%M&quot;).sql\n\n参数详解\n–opt起到优化的作用，和–add-drop-table, –add-locks, –create-options, –skip-opt作用相似。\n-Q将表名和列名使用 ``包裹。以防他们是关键字时报错。\n–default-character-set 设置导出的字符集\n\n删除沉余备份删除30天前备份的沉余数据\n#!/bin/shfind /$(pwd) -name &#x27;*.sql&#x27; -mtime +30 -exec rm -rf &#123;&#125; \\;\n\n\n\n","tags":["MySQL","Linux"]},{"title":"使用vue-cli创建前端项目","url":"/2019/09/07/%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/","content":"使用vue-cli建项记录，避免以后再次踩坑。\n\n安装vue-cli包\nnpm install -g @vue/cli\n全局扩展安装\nnpm install -g @vue/cli-service-global\n在文件夹内创建App.vue文件并且写入\n&lt;template&gt;  &lt;h1&gt;Hello!&lt;/h1&gt;&lt;/template&gt;\n在刚刚创建的文件夹下输入命令\nvue serve\n\n官网提示：vue serve 使用了和 vue create 创建的项目相同的默认设置 (webpack、Babel、PostCSS 和 ESLint)。它会在当前目录自动推导入口文件——入口可以是 main.js、index.js、App.vue 或 app.vue 中的一个。\n\n\n以上是vue-cli环境搭建和基础命令使用。\n\n创建一个项目使用下面这个命令创建一个项目\nvue create fuck-door\n\n然后会弹出选项， 我选择默认快速创建，其他配置我看了一下以后用到再加。\n还可以用下面这个命令查看创建的更多方法\nvue create --help\n\n还有一种跟简单粗暴的方式直接在网页中创建项目\nvue ui\n\n恕我直言 ，vue-cli创建项目和用vue ui 添加插件爽到我了XD….\n添加element-ui在项目文件夹内输入\nvue add element\n\nhttps://github.com/ElementUI/vue-cli-plugin-element\n根据提示安装即可。\n当然这一步也可以在上面 vue ui里plugins找到element ui plugins 添加创建element ui项目。\n","categories":["Vue"],"tags":["Vue"]},{"title":"在ESXi上手动控制服务器风扇","url":"/2020/10/18/%E5%9C%A8ESXi%E4%B8%8A%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A3%8E%E6%89%87/","content":"场景因为服务器是放在家里的，秋天冬天服务器CPU温度不会太高，暂时也没那么多占用资源的应用。\n并且戴尔 R620服务器在PCIE上插上显卡后，CPU的风扇就一直是起飞状态..噪音污染，实际并没有那么大的功耗。\n开始在ESXi初始见面打开服务器显示器 键盘键入F2，输入密码好找到【Troubleshooting Options】\n打开：ESXi Shell 与 SSH 2个选项\n然后Xshell远程到服务器ESXi ，输入以下命令\nwget  dl.kvm.la/tools/esxi_ipmitool-1.8.15-1.vib -O  /var/log/vmware/ipmitool-1.8.15-1.vibesxcli software acceptance set --level=CommunitySupportedesxcli software vib install -v ipmitool-1.8.15-1.vib\n\n手动修改风扇速度# first,which allows you to edit the fan speed/opt/ipmitool/bin/ipmitool raw 0x30 0x30 0x01 0x00# then set the fan speed by editing last hex code.(0x0a=10%,0x0f=15%,0x1a=26%)/opt/ipmitool/bin/ipmitool raw 0x30 0x30 0x02 0xff 0x1a# revert back to system control of the fans/opt/ipmitool/bin/ipmitool raw 0x30 0x30 0x01 0x01\n\n第二个命令最后的十六进制是风扇的效率，是十进制换算成十六进制替换输入进去即可。\n","tags":["服务器","ESXi"]},{"title":"如何在coding上部署hexo","url":"/2016/11/30/%E5%A6%82%E4%BD%95%E5%9C%A8Coding%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo/","content":"前言\n终于完成了！\n\n这是我第一次使用Hexo博客，在对很多内容感觉还是很迷的情况下终于配置完成了Hexo，说来惭愧连MarkDown语法都没熟练掌握就开始想着手写文章了。本鸟也是看见身边不少的朋友在使用Hexo博客心血来潮就想折腾一番，在Windows环境下也踩了很多坑。\n关于教程\n最好的文档肯定是官方文档 『简体中文Hexo文档』\n\n这一点是毋庸置疑的，但是为了避免踩坑，我还是推荐一开始还是阅读别人的博客相关文档来解决问题，这里我推荐一个我认为写的比较好的教程，配合文档阅读效果极佳。\n部署到哪里呢？\n被墙的感觉真难受啊。\n\nGitHub国内访问犹如便秘一般，我在这里推荐一个访问比较快的国内Git远程仓库Coding，不要吐槽和我的域名很像2333。关于Git的教程网上很多，在创建coding-pages服务生成分支后，可以在分支选项卡里切换coding-pages分支为主分支，然后删除master分支[避免强迫症发作]。\ngit配置文件修改\n_config.yml文件修改\n\ndeploy:  type: git  repo: https://git.coding.net/&lt;Username&gt;/Hexo-Blog.git  branch: coding-pages\n\n然后把hexo d 推送到coding-pages远程仓库上。\n友情链接欢迎各位大佬和本鸟互换友链，本站的主页http://codinger.cn/\n","categories":["教程"],"tags":["Hexo"]},{"title":"寻址方式在结构化数据访问","url":"/2017/08/27/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%9C%A8%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/","content":"寻址方式在结构化数据访问题目\n代码assume cs:codesg,ds:data,es:tabledata segment    db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;    db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;    db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;    dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226    dw 11452,14430,15257,17800data endstable segment    db 21 dup (&#x27;0000 0000 00 00 &#x27;)table endscodesg segment start:\tmov ax,data\t\tmov es,ax\t\tmov ax,table\t\tmov ds,ax\t\tmov bx,0\t\tmov di,0\t\tmov si,0\t\tmov cx,21\ts1:\t\t\tmov ax,es:[di]\t\tmov ds:[bx],ax\t\tadd di,2\t\tmov ax,es:[di]\t\tmov ds:[bx][2],ax\t\tadd di,2\t\tadd bx,0010h\tloop s1\t\t\tmov bx,0\t\tmov cx,21\ts2: mov ax,es:[di]\t\tmov [bx][5],ax\t\tadd di,2\t\tmov ax,es:[di]\t\tmov ds:[bx][7],ax\t\tadd di,2\t\tadd bx,0010h\tloop s2\t\tmov bx,0\t\tmov cx,21\ts3: mov ax,es:[di]\t\tmov [bx][10],ax\t\tadd di,2\t\tadd bx,0010h\tloop s3\t\tmov bx,0\t\tmov cx,21\ts4: mov ax,[bx][5]\t\tmov dx,[bx][7]\t\tdiv word ptr [bx+10]\t\tmov [bx][13],ax\t\tmov bx,0010h\tloop s4\t\tmov ax,4c00h\t\tint 21codesg endsend start\n调试\n","categories":["汇编"],"tags":["笔记","汇编"]},{"title":"检测比较结果条件转移指令","url":"/2017/09/09/%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4/","content":"if(ah==ah)&#123;  ah=+ah;&#125;else&#123;  ah=+bh;&#125;\n\n对应的汇编命令\nassume cs:codecode segmentstart:\tmov ah,1h\t\tmov bh,1h\t\t\t\tcmp ah,bh\t\tje s\t\tadd ah,bh\t\tjmp ok  \ts:\tadd ah,ah\tok:\tmov ax,4c00h\t\tint 21\tcode endsend start\n\n\n\n2）统计data段中的数值为8的字节个数，用ax保存统计结果\nassume cs:codedata segmentdb 8,11,8,1,8,5,63,38data endscode segmentstart: mov ax,data\t   mov ds,ax\t   mov ax,0\t   mov bx,0\t   mov cx,8\t   \t s: cmp byte ptr [bx],8\t\tjne next\t\tinc ax  next: inc bx\t\tloop s\t\tmov ax,4c00h\tint 21code endsend start\n\n\n\n方法二：\n\tassume cs:codedata segmentdb 8,11,8,1,8,5,63,38data endscode segmentstart: mov ax,data\t   mov ds,ax\t   mov ax,0\t   mov bx,0\t   mov cx,8\t   \t s: cmp byte ptr [bx],8\t\tje ok\t\tjmp short next    ok: inc ax  next: inc bx\t\tloop s\t\tmov ax,4c00h\tint 21code endsend start\n\n3）统计data段中数值大于8的字节的个数，用ax保存统计结果\nassume cs:codedata segmentdb 8,11,8,1,8,5,63,38data endscode segmentstart: mov ax,data\t   mov ds,ax\t   mov ax,0\t   mov bx,0\t   mov cx,8\t   \t s: cmp byte ptr [bx],8\t\tja ok\t\tjmp short next    ok: inc ax  next: inc bx\t\tloop s\t\tmov ax,4c00h\tint 21code endsend start\n方法二：\nassume cs:codedata segmentdb 8,11,8,1,8,5,63,38data endscode segmentstart: mov ax,data\t   mov ds,ax\t   mov ax,0\t   mov bx,0\t   mov cx,8\t   \t s: cmp byte ptr [bx],8\t\tjna next\t\tinc ax  next: inc bx\t\tloop s\t\tmov ax,4c00h\tint 21code endsend start\n\n4）统计data段中数值小于8的字节个数，用ax保存统计结果\nassume cs:codedata segmentdb 8,11,8,1,8,5,63,38data endscode segmentstart: mov ax,data\t   mov ds,ax\t   mov ax,0\t   mov bx,0\t   mov cx,8\t   \t s: cmp byte ptr [bx],8\t\tjnb next\t\tinc ax  next: inc bx\t\tloop s\t\tmov ax,4c00h\tint 21code endsend start\n\n","categories":["汇编"],"tags":["笔记","汇编"]},{"title":"汇编Loop和[bx]的联合应用","url":"/2017/08/17/%E6%B1%87%E7%BC%96Loop%E5%92%8C-bx-%E7%9A%84%E8%81%94%E5%90%88%E5%BA%94%E7%94%A8/","content":"assume cs:codesgcodesg segment\tmov ax,0ffffh \t\t;累加寄存器负责把ffffh传送给ds段地址\tmov bx,0000h\t\t;基地址寄存器为下面循环偏移做初始化\tmov cx,12\t\t;计数器寄存器初始化，为循环做准备循环12次\tmov dx,0000h\t\t;数据寄存器,为了避免超界会利用ax累加后传送到DX\tmov ds,ax\tmov ah,0000h\t\t;初始化高八位单元\t\ti: mov al,[bx]\t\t;循环体把ds:bx的8位数据等位传送到低八位al中\tadd dx,ax\t\t;(dx)=(dx)+(ax)\tinc bx\t\t\t;bx++\t\tloop i\t\t\t;判断cx是否为0如果为0结束循环\t\tmov ax,4c00h\t\t;结束程序\tint 21hcodesg endsend","categories":["汇编"],"tags":["笔记","汇编"]},{"title":"更灵活的定位内存地址的方法","url":"/2017/08/21/%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/","content":"更灵活的定位内存地址的方法汇编大小写转换assume cs:code,ds:datadata segmentdb &#x27;BaSiC&#x27; ;把这个字符串全部变为大写db &#x27;iNfOrMaTiOn&#x27; ;把这个字符串全部变为小写data endscode segmentstart:  mov ax,data\t ;获取数据代码段地址\t\tmov ds,ax \t ;把代码段地址传送到数据寄存器\t\tmov bx,0\t ;初始化基地址寄存器  笔记（ds与bx配合，es与dx配合，cx作为计数器）\t\tmov cx,5s: \t\tmov al,[bx]  ;循环体\t\tand al,11011111b ;b是二进制 对al的值进行位与运算取反\t\tmov [bx],al\t\tinc bx\t\tloop s\t\t\t\tmov bx,5\t;指向下一个字符串\t\tmov cx,11\t;循环11次\t\ts1:\t\tmov al,[bx]\t\tor al,00100000b\t;对al的值进行位或运算取反 \t\tmov [bx],al\t\tinc bx\t\tloop s1\t\tmov ax,4c00h\t\tint 21code endsend start\n\n使用[bx+idata]的方法优化程序assume cs:code,ds:datadata segmentdb &#x27;BaSiC&#x27;db &#x27;MinIX&#x27;data endscode segmentstart: mov ax,data\tmov ds,ax\tmov bx,0\tmov cx,5\ts: mov al,[bx]\tand al,11011111b\tmov [bx],al\t\tmov al,[5+bx]\tor al,00100000b\tmov [5+bx],al\tinc bx\tloop s\tmov ax,4c00h\tint 21code endsend start\n\n\n\n\nSI AND DIsi和di不能分成2个8位寄存器，也就是不能进行mov al,[si] ,mov al,[di]这样的操作，下面写一个栗子~\nassume cs:codesm,ds:datasgdatasg segmentdb &#x27;welcome to masm!&#x27;db &#x27;................&#x27;datasg endscodesm segmentstart: mov ax,datasg\tmov ds,ax\tmov si,0\tmov di,16\t\tmov cx,8\ts:\tmov ax,[si]\tmov [di],ax\tadd si,2\tadd di,2\tloop s\t\tmov ax,4c00h\tint 21\tcodesm endsend start\n\n上面的代码可以看出si,di递增为2 ，循环次数也缩短了一倍，用16位寄存器进行内存单元之间的数据传送一次复制2 个字节，一共循环八次。\n再次优化：\nassume cs:codesm,ds:datasgdatasg segmentdb &#x27;welcome to masm!&#x27;db &#x27;................&#x27;datasg endscodesm segmentstart: mov ax,datasg\tmov ds,ax\tmov si,0\tmov cx,8\ts:\tmov ax,[si]\tmov [si+16],ax\tinc si,2\tloop s\t\tmov ax,4c00h\tint 21\tcodesm endsend start\n将字符串头一个字母改为大写assume cs:codesg,ds:datasgdatasg segmentdb &#x27;1. file         &#x27;db &#x27;2. edit         &#x27;db &#x27;3. search       &#x27;db &#x27;4. view         &#x27;db &#x27;5. options      &#x27;db &#x27;6. help         &#x27;datasg endscodesg segmentstart: mov ax,datasg\tmov ds,ax\tmov bx,0\tmov cx,6\tmov si,3s:\tmov al,[bx][si]\tand al,11011111b\tmov [bx][si],al\tadd bx,16\t\tloop s\tmov ax,4c00h\tint 21codesg endsend start\n\n嵌套循环(把datasg每个单词改为大写)assume cs:codesg,ds:datasgdatasg segmentdb &#x27;ibm             &#x27;db &#x27;dec             &#x27;db &#x27;dos             &#x27;db &#x27;vax             &#x27;datasg endscodesg segmentstart: mov ax,datasg\tmov ds,ax\tmov bx,0\tmov cx,4\t;外层循环4次s:\tmov dx,cx\t;因为进行下一次循环不能保存CX利用dx暂存\tmov si,0\tmov cx,3\t;内层循环3次s0:\tmov al,[bx][si]\t\tand al,11011111b\tmov [bx][si],al\tinc siloop s0\tadd bx,16\t;每次内循环完成偏移到下一段字符串\tmov cx,dxloop s\tmov ax,4c00h\tint 21\tcodesg endsend start\n讲道理汇编的嵌套循环有点不习惯….这只是2层嵌套 如果更多嵌套则寄存器不够用，这时候我们就不能用寄存器来暂存CX了\n用栈来处理cx缓存问题将datasg数据段每个单词前4个字幕改为大写\nassume cs:codesg,ds:datasg,ss:stacksgdatasg segmentdb &#x27;1. display      &#x27;db &#x27;2. brows        &#x27;db &#x27;3. replace      &#x27;db &#x27;4. modify       &#x27;datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endscodesg segmentstart: mov ax,datasg\tmov ds,ax\tmov bx,0\tmov cx,4\ti0: mov ax,[bx]\tpush cx\t\t\t\t;保存外层循环次数\tmov cx,2\t\t\t;初始化内层循环次数\tmov di,0i1:\tmov ax,[bx][3][di]\t; (ax)=(bx)+(di)+3\tand al,11011111b\t; 因为di是16位寄存器所以要利用把ax拆开与运算\tand ah,11011111b\t;这样做的目的是为了减少循环次数\tmov [bx][3][di],ax\t;把处理后的ax传送到原来的位置\tadd di,2\t\t\t;(di)=(di)+2  di地址偏移2个字单元\tloop i1\tadd bx,16\t\t\t;把基地址便宜到下一行字符串\tpop cx\t\t\t\t;把刚才push的cx出栈\t\tloop i0\tmov ax,4c00h\tint 21\tcodesg endsend start\n\n\n","categories":["汇编"],"tags":["笔记","汇编"]},{"title":"让家庭网络使用ipv4的80端口","url":"/2020/09/21/%E8%AE%A9%E5%AE%B6%E5%BA%AD%E5%AE%BD%E5%B8%A6%E4%BD%BF%E7%94%A8ipv4%E7%9A%8480%E7%AB%AF%E5%8F%A3/","content":"前提摘要​    众所周知各大运营商（移动、电信、联通）封杀了很多端口，比如80、443、445、139。导致无法搭建一些利于自己的服务。本篇教程就教你如何通过域名代理，绕过运营商来访问本地端口的策略。另外，如果是内网，运营商没有分配给你公网ip地址，首先打电话询问是否可以转换公网ip(你可以套路客服别问的太直接)，不行的话或者就再搭建个内网穿透FRP啥的这里不做细说。\n准备工作\nOpenwrt系统路由器\n\n一台服务器或其他主机 nginx服务等Web应用\n\n购买域名并且设置DNS服务器为cloudflare进行解析\n\nhe.net的tunnelbroker服务注册\n\n保证WAN口ipv4的稳定性：给运营商打电话(“啊呀！我这么网络又掉线了！我看我ip变了，拨号太频繁了吧！！@#￥%……&amp;”)\n运营商在给你创建宽带的时候会默认带一个隐藏服务就是每隔24小时内会给你重新拨号释放ip地址，投诉给客服取消掉。\n\n\n开始openwrt配置首先你必须拥有openwrt系统的路由或者软路由，软件包里安装了6in4这个包，如果没有可以如下 进入路由器里面输入命令：\nopkg updateopkg install 6in4\n\n或者在路由个GUI界面中 ：系统-&gt;软件包去安装，\n安装可能会遇到墙的问题，或者替换opkg的源，或者上代理这个就不细说了。\n安装完成后到：网络-&gt;接口 ：添加新的接口，在接口协议中查看有没有ipv6-in-ipv4这个选项，\n如果有就代表安装成功，切换这个协议后创建提交，然后准备其他工作。\ntunnelBroker配置创建公网ipv6去注册tunnelbroker服务，找到Create Regular Tunnel。\n填写 IPv4 Endpoint (Your side)：你自己的运营商分配给你的IP地址（推荐乱填一个可用的）\n接下来很重要的一步就是找到可用的隧道节点，朋友告诉我当前可用的隧道ip为：64.62.134.130 (Ctrl+F找更快) ，我当前就是使用的这个隧道，其他的时间充裕您可以自己测试没问题的话告诉我哈。\n然后点击 Create Tunnel 按钮进入下一步，点击Example Configurations，选择OpenWRT\n\n把以上资料填入刚刚Openwrt 6in4接口配置中入下图：\n\n创建成功后到接口列表中查看自己的ipv4地址，和6in4是否正常运作，上面勾选了动态隧道，所以你的Ipv4地址会把刚刚一开始创建 IPv4 Endpoint胡乱填的地址给覆盖掉，打开tunnelbroker -&gt; ipv6 tunnel  -&gt; IPv6 Tunnel Endpoints -&gt;Client IPv4 Address 如果覆盖掉就代表创建成功了。\n成功如下图：\n\n域名与解析配置我域名都是在gandi上购买的，阿里云万网还要实名认证 身份证啥的 懂得都懂:smile: ….\n gandi上DNS设置在 名称伺服器 里设置 cloudflare的DNS地址：\nfiona.ns.cloudflare.comtheo.ns.cloudflare.com\n\n打开cloudflare 添加站点 输入你注册的域名 选择免费套餐 扫描你的解析\n然后进入DNS，把你需要解析的域名添加aaaa记录并且打开代理如：\n\n这里的ipv6是你在he.net申请的路由器下发的完整地址下面服务器配置里会说明这个ipv6填的内容\n服务器配置输入命令：\nifconfig -a\n\n会得到你的服务器接口和分配的ip地址\n查看打开tunnelbroker -&gt; ipv6 tunnel  -&gt; IPv6 Tunnel Endpoints -&gt;Client IPv6 Address\n对比刚刚ifcofnig -a里的结果前缀相同完整ipv6 prefixlen 64 地址给复制出来填入上面域名解析\n在nginx里配置 重载即可\nlisten [::]:443 ssl http2;\nlisten [::]:80;\nserver_name www.iacg.moe;\n\n现在你的Web或者其他服务，就可以通过cloudflare的ipv6代理的域名访问家庭内的任何机器的ipv6了:smiley:\n感谢这里感谢阿夜提供给我的知识与技术支持OwO\n","categories":["教程"],"tags":["ipv6","ipv4","代理","tunnelbroker"]},{"title":"远程联调端口映射内网穿透总结","url":"/2021/11/18/%E8%BF%9C%E7%A8%8B%E8%81%94%E8%B0%83%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%80%BB%E7%BB%93/","content":"场景与目的描述目的为了开发本地电脑可以远程调试内网海康服务器1883等端口\n所用服务器\n海康服务器（只有华为服务器可以访问这台海康服务器443 1883）\n华为服务器（只有运维电脑可以访问这台SSH和其他任意端口 ）\n运维本地电脑（内网环境，依赖手机WiFi提供外网访问渠道，只可以访问华为服务器）\nFRP服务器（外网服务器用作映射运维电脑端口）\n开发本地电脑（有外网 访问FRP服务器）\n\n开始映射第一步目的：让运维电脑可以通过华为服务器映射海康服务器访问1883端口\n首先在华为服务器安装**tinymapper_binaries.tar.gz**\n这是一个端口映射的开源项目：https://github.com/wangyu-/tinyPortMapper 在服务器上没有其他依赖包很方便\n使用方法很简单：（比如我想映射1883 443端口）\n解压出二进制文件后给上执行权限（chmod +x tinymapper_amd64）后：\n`nohup ./tinymapper_amd64 -l0.0.0.0:1234 -r10.224.32.7:443 -t -u &gt;&gt; tinymapper_1234.log 2&gt;&amp;1 &amp;``nohup ./tinymapper_amd64 -l0.0.0.0:1883 -r10.224.32.10:1883 -t -u &gt;&gt; tinymapper_1883.log 2&gt;&amp;1 &amp;`\n\n缩写含义：\n\n-l 本地ip端口\n-r 远程ip端口\n-t TCP协议\n-u UDP协议\n\n这样就可以在运维电脑上通过华为服务器映射出端口直接访问海康服务器的1883的端口。\n第二步目的：开发电脑通过FRP内网穿透远程访问运维电脑端口。\n这里服务端有2种方案：\n\n通过别人的已经搭建好的FRP服务端和现成的工具（优点：方便，缺点：安全性）\nhttps://www.natfrp.com/\n实名认证 （1元）\n\n\n自己搭建FRP服务端\n开源项目：https://github.com/fatedier/frp ，百度关键字：linux frp 服务端 （优点:自己搭建安全, 相对有搭建成本）\n\n\n\n为了节约时间成本 这里用Skura FRP做内网穿透，在运维电脑上安装好FRP客户端，并且在https://www.natfrp.com/tunnel/ 创建好穿透隧道，这里FRP的本地IP/端口填写需要映射的华为服务器IP和需要映射端口（1883），运行客户端。（注意：别选择被墙的IP来做FRP服务端）\n第三步现在开发本地已经可以访问内网海康服务器进行联调\n海康服务器&lt;——&gt;(映射)华为服务器&lt;——&gt;运维电脑FRP穿透&lt;——&gt;FRP服务器——&gt;开发本地电脑\n开发本地只需要使用刚刚创建的穿透隧道服务器的IP地址和所映射的端口，就能直接访问海康服务器1883端口数据了。\n","categories":["内网穿透"],"tags":["开发远程调试","内网穿透","frp","tinymapper"]},{"title":"远程访问服务端DDNS非标samba端口","url":"/2020/02/02/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%AB%AFDDNS%E9%9D%9E%E6%A0%87samba%E7%AB%AF%E5%8F%A3/","content":"​        最近给家里的服务器加了硬盘，现在服务器有足够的磁盘空间想利用起来，局域网下访问samba服务是没有问题的，但是运营商封禁了TCP的445、139端口，导致远程主机无法访问到我服务器上的服务。下面来说解决方案。\nSTEP 1 路由转发端口路由器先做端口映射，我路由器使用的Openwrt固件，\n在做转发前要确认samba服务器防火墙端口是否放行 445、139可用客户端telnet 192.168.1.233 445，这里192.168.1.233是局域网服务器IP。\n在防火墙内的端口转发：路由器4455、1399端口 转发 到samba服务器445、139端口。\n保存防火墙配置后，在客户端测试telnet samba.com 4455测试是否成功转发，samba.com是的DDNS后的域名。\nSTEP2 客户端转发samba端口打开管理员权限的powershell，输入下面的添加端口转发命令即可\nnetsh interface portproxy add v4tov4 listenport=445 listenaddress=127.0.0.1 connectport=4455 connectaddress=183.163.25.217\n\nnetsh interface portproxy add v4tov4 listenport=139 listenaddress=127.0.0.1 connectport=1399 connectaddress=183.163.25.217\n"},{"title":"Laravel搭建迷你博客","url":"/2017/06/13/Laravel%E6%90%AD%E5%BB%BA%E8%BF%B7%E4%BD%A0%E5%8D%9A%E5%AE%A2/","content":"部署项目是直接部署在WampServer环境  版本：3.0.6 （PHP7.0+）\n安装框架使用composer包管理器安装Laravel框架，使用的是Laravel5.4版本\ncomposer create-project laravel/laravel blog --prefer-dist\n\n配置Apache&lt;VirtualHost *:80&gt;\tServerName miniblog.com\tDocumentRoot G:/wamp64/www/blog/public/\t&lt;Directory  &quot;G:/wamp64/www/blog/public/&quot;&gt;\t\tOptions +Indexes +Includes +FollowSymLinks +MultiViews\t\tAllowOverride All\t\tRequire all granted\t&lt;/Directory&gt;&lt;/VirtualHost&gt;\n\n添加Hosts\n127.0.0.1    miniblog.com\n\n数据库配置创建数据库\nCREATE DATABASE blog /*!40100 COLLATE ‘utf8mb4_general_ci’ */;\n修改.env文件\nAPP_NAME=迷你博客DB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=blogDB_USERNAME=rootDB_PASSWORD=\n\n开始制作创建控制器php artisan make:controller ArticlesController\n\n创建路由打开routes文件夹中web.php加入以下代码：\nRoute::resource(&#x27;articles&#x27;,&#x27;ArticlesController&#x27;);\n\n只需要上面这样一行代码，就相当于创建了如下7条路由，且都是命名路由，我们可以使用类似route(&#39;articles.show&#39;) 这样的用法。\nRoute::get(&#x27;/articles&#x27;, &#x27;ArticlesController@index&#x27;)-&gt;name(&#x27;articles.index&#x27;);Route::get(&#x27;/articles/&#123;id&#125;&#x27;, &#x27;ArticlesController@show&#x27;)-&gt;name(&#x27;articles.show&#x27;);Route::get(&#x27;/articles/create&#x27;, &#x27;ArticlesController@create&#x27;)-&gt;name(&#x27;articles.create&#x27;);Route::post(&#x27;/articles&#x27;, &#x27;ArticlesController@store&#x27;)-&gt;name(&#x27;articles.store&#x27;);Route::get(&#x27;/articles/&#123;id&#125;/edit&#x27;, &#x27;ArticlesController@edit&#x27;)-&gt;name(&#x27;articles.edit&#x27;);Route::patch(&#x27;/articles/&#123;id&#125;&#x27;, &#x27;ArticlesController@update&#x27;)-&gt;name(&#x27;articles.update&#x27;);Route::delete(&#x27;/articles/&#123;id&#125;&#x27;, &#x27;ArticlesController@destroy&#x27;)-&gt;name(&#x27;articles.destroy&#x27;);\n\n如果你使用的PHPStrom的自带终端或者其他终端软件，在项目文件夹下输入\nphp artisan route:list\n\n可以查看到路由表所有信息。\n创建注册登录这里还是使用Laravel自带的注册登录组件，在项目下的终端输入\nphp artisan make:auth\n验证码扩展包Composer验证码包简介：https://packagist.org/packages/mews/captcha\n也用中文验证码包：https://packagist.org/packages/kangkang66/captcha\n安装composer require mews/captcha\n配置使用Captcha服务提供者之前还需要在config/app.php中注册服务提供者：\n&#x27;providers&#x27; =&gt; [    // ...    Mews\\Captcha\\CaptchaServiceProvider::class,]\n\n同时注册下相应门面：\n&#x27;aliases&#x27; =&gt; [    // ...    &#x27;Captcha&#x27; =&gt; Mews\\Captcha\\Facades\\Captcha::class,]\n\n如果要使用自定义的配置，还可以发布配置文件到config目录：\nphp artisan vendor:publish\n\n编辑新生成的Captcha.php\n重写默认登录注册验证方法找到：app\\Http\\Controllers\\Auth\\LoginController.php进入use AuthenticatesUsers类找到validateLogin方法，修改验证方法代码如下：\nprotected function validateLogin(Request $request)&#123;    $this-&gt;validate($request, [        $this-&gt;username() =&gt; &#x27;required|string&#x27;,        &#x27;password&#x27; =&gt; &#x27;required|string&#x27;,        &#x27;captcha&#x27; =&gt;&#x27;required|captcha|max:5|string&#x27;    ],[        &#x27;captcha.captcha&#x27;=&gt;trans(&#x27;验证码错误！&#x27;),        &#x27;captcha.required&#x27;=&gt;trans(&#x27;验证码为必须！&#x27;),    ]);&#125;\n\n同理，也可以在注册也添加上验证码：找到app\\Http\\Controllers\\Auth\\RegisterController.php修改验证：\nprotected function validator(array $data)&#123;    return Validator::make($data, [        &#x27;name&#x27; =&gt; &#x27;required|string|max:255&#x27;,        &#x27;email&#x27; =&gt; &#x27;required|string|email|max:255|unique:users&#x27;,        &#x27;password&#x27; =&gt; &#x27;required|string|min:6|confirmed&#x27;,        &#x27;captcha&#x27;=&gt;&#x27;required|max:5|captcha|string&#x27;    ],[        &#x27;captcha.captcha&#x27;=&gt;trans(&#x27;验证码错误！&#x27;),        &#x27;captcha.required&#x27;=&gt;trans(&#x27;验证码为空！&#x27;)    ]);&#125;\n对视图文件的添加\n添加验证码图片+验证\n\n&lt;div class=&quot;form-group&#123;&#123; $errors-&gt;has(&#x27;captcha&#x27;) ? &#x27; has-error&#x27; : &#x27;&#x27; &#125;&#125;&quot;&gt;    &lt;label for=&quot;text&quot; class=&quot;col-md-4 control-label&quot;&gt;验证码&lt;/label&gt;    &lt;div class=&quot;col-md-6&quot;&gt;        &lt;input id=&quot;text&quot; type=&quot;captcha&quot; class=&quot;form-control&quot; name=&quot;captcha&quot; required&gt;        &lt;br/&gt;        &lt;span class=&quot;input-group-btn&quot;&gt;            &lt;img style=&quot;&quot; src=&quot;&#123;&#123;captcha_src()&#125;&#125;&quot;                 onclick=&quot;this.src=&#x27;&#123;&#123;captcha_src()&#125;&#125;&#x27; + Math.random()&quot;&gt;        &lt;/span&gt;        @if ($errors-&gt;has(&#x27;captcha&#x27;))            &lt;span class=&quot;help-block&quot;&gt;                &lt;strong&gt;&#123;&#123; $errors-&gt;first(&#x27;captcha&#x27;) &#125;&#125;&lt;/strong&gt;            &lt;/span&gt;        @endif    &lt;/div&gt;&lt;/div&gt;\n创建数据表利用 artisan 命令生成迁移：\nphp artisan make:migration create_articles_talbe\n\n然后打开迁移文件：\ndatabase/migrations/XXXX_create_articles_table.php\n&lt;?phpuse Illuminate\\Support\\Facades\\Schema;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Database\\Migrations\\Migration;class CreateArticlesTable extends Migration&#123;    /**     * Run the migrations.     *     * @return void     */    public function up()    &#123;        Schema::create(&#x27;articles&#x27;,function (Blueprint $table)&#123;            $table-&gt;increments(&#x27;id&#x27;);            $table-&gt;string(&#x27;title&#x27;);            $table-&gt;longText(&#x27;content&#x27;)-&gt;nullable();            $table-&gt;timestamps();        &#125;);    &#125;    /**     * Reverse the migrations.     *     * @return void     */    public function down()    &#123;        Schema::dropIfExists(&#x27;articles&#x27;);    &#125;&#125;\n\n在Laravel5.4中要修改默认字符串长度，app/Providers/AppServiceProvider.php\n&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Schema;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider&#123;    /**     * Bootstrap any application services.     *     * @return void     */    public function boot()    &#123;        Schema::defaultStringLength(191);    &#125;    /**     * Register any application services.     *     * @return void     */    public function register()    &#123;        //    &#125;&#125;\n\n生成数据表在终端里输入\nphp artisan migrate\n\n如果有错误或者需要修改，可以使用下面命令\nphp artisan migrate:rollback\n\n创建模型利用 artisan 命令创建模型：\nphp artisan make:model Article\n\n打开模型文件，输入以下代码：\napp/Article.php\n&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Article extends Model&#123;    protected $table = &#x27;articles&#x27;;    protected $fillable = [        &#x27;title&#x27;,        &#x27;content&#x27;,    ];&#125;\n\n这样就可以指定某个表的可写字段。\nphp artisan route:list\n\n可以查看到每个路由的控制器的方法\n+--------+-----------+-------------------------+------------------+------------------------------------------------------------------------+--------------+| Domain | Method    | URI                     | Name             | Action                                                                 | Middleware   |+--------+-----------+-------------------------+------------------+------------------------------------------------------------------------+--------------+|        | GET|HEAD  | /                       |                  | Closure                                                                | web          ||        | GET|HEAD  | api/user                |                  | Closure                                                                | api,auth:api ||        | GET|HEAD  | articles                | articles.index   | App\\Http\\Controllers\\ArticlesController@index                          | web          ||        | POST      | articles                | articles.store   | App\\Http\\Controllers\\ArticlesController@store                          | web          ||        | GET|HEAD  | articles/create         | articles.create  | App\\Http\\Controllers\\ArticlesController@create                         | web          ||        | GET|HEAD  | articles/&#123;article&#125;      | articles.show    | App\\Http\\Controllers\\ArticlesController@show                           | web          ||        | PUT|PATCH | articles/&#123;article&#125;      | articles.update  | App\\Http\\Controllers\\ArticlesController@update                         | web          ||        | DELETE    | articles/&#123;article&#125;      | articles.destroy | App\\Http\\Controllers\\ArticlesController@destroy                        | web          ||        | GET|HEAD  | articles/&#123;article&#125;/edit | articles.edit    | App\\Http\\Controllers\\ArticlesController@edit                           | web          ||        | GET|HEAD  | home                    | home             | App\\Http\\Controllers\\HomeController@index                              | web,auth     ||        | GET|HEAD  | login                   | login            | App\\Http\\Controllers\\Auth\\LoginController@showLoginForm                | web,guest    ||        | POST      | login                   |                  | App\\Http\\Controllers\\Auth\\LoginController@login                        | web,guest    ||        | POST      | logout                  | logout           | App\\Http\\Controllers\\Auth\\LoginController@logout                       | web          ||        | POST      | password/email          | password.email   | App\\Http\\Controllers\\Auth\\ForgotPasswordController@sendResetLinkEmail  | web,guest    ||        | GET|HEAD  | password/reset          | password.request | App\\Http\\Controllers\\Auth\\ForgotPasswordController@showLinkRequestForm | web,guest    ||        | POST      | password/reset          |                  | App\\Http\\Controllers\\Auth\\ResetPasswordController@reset                | web,guest    ||        | GET|HEAD  | password/reset/&#123;token&#125;  | password.reset   | App\\Http\\Controllers\\Auth\\ResetPasswordController@showResetForm        | web,guest    ||        | GET|HEAD  | register                | register         | App\\Http\\Controllers\\Auth\\RegisterController@showRegistrationForm      | web,guest    ||        | POST      | register                |                  | App\\Http\\Controllers\\Auth\\RegisterController@register                  | web,guest    |+--------+-----------+-------------------------+------------------+------------------------------------------------------------------------+--------------+\n\n\n\n创建、修改视图然后在 resources/views 目录下新建一个文件夹 articles ，然后在 resources/views/articles 目录下新建文件 edit.blade.php、create.blade.php、index.blade.php。\n修改create.blade.php\n@extends(&#x27;layouts.app&#x27;)@section(&#x27;content&#x27;)    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col-md-10 col-md-offset-1&quot;&gt;                &lt;form action=&quot;&#123;&#123;route(&#x27;articles.store&#x27;)&#125;&#125;&quot; method=&quot;post&quot; role=&quot;form&quot;&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &#123;&#123; csrf_field() &#125;&#125;                        &lt;label for=&quot;title&quot;&gt;标题&lt;/label&gt;                        &lt;input class=&quot;form-control&quot; type=&quot;text&quot; name=&quot;title&quot; value=&quot;&#123;&#123;old(&#x27;title&#x27;)&#125;&#125;&quot;&gt;                        &lt;label for=&quot;name&quot;&gt;文本框&lt;/label&gt;                        &lt;textarea class=&quot;form-control&quot; name=&quot;articleContent&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt;                        &lt;button class=&quot;btn btn-primary&quot; style=&quot;margin-top:8px; float: right&quot; type=&quot;submit&quot;&gt;提交&lt;/button&gt;                    &lt;/div&gt;                &lt;/form&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    @endsection\n\n创建文章然后在ArticlesController.php创建create()的方法\npublic function create()&#123;    return view(&#x27;articles.create&#x27;);&#125;\n\n现在就可以访问http://xxxxx/articles/create，显示创建文章视图，From访问的是储存文章的路由。现在可以写储存文章的方法了。\n储存文章打开 ArticlesController.php 控制器，创建store() 方法。\n&lt;?phpnamespace App\\Http\\Controllers;use App\\Article;//因为这段代码中用到了Eloquent 模型的构造器用法，所以需要引入我们之前创建的模型。use Illuminate\\Http\\Request;class ArticlesController extends Controller&#123;    public function store(Request $request)&#123;        $this-&gt;validate($request,[            &#x27;title&#x27;=&gt;&#x27;required|max:50&#x27;,//在收到表单传过来的数据时，可以先对表单数据进行验证        ]);        $article = Article::create([            &#x27;title&#x27; =&gt; $request-&gt;title,            &#x27;content&#x27; =&gt; $request-&gt;articleContent,        ]);        return redirect()-&gt;route(&#x27;article.index&#x27;);//最后完成文章的创建，然后重定向到文章列表页    &#125;&#125;\n\n文章首页创建index()方法\npublic function index()&#123;    $articles = Article::orderBy(&#x27;created_at&#x27;,&#x27;desc&#x27;)-&gt;get();    return view(&#x27;articles.index&#x27;,compact(&#x27;articles&#x27;));&#125;\n\n修改articles.index的视图\n@extends(&#x27;layouts.app&#x27;)@section(&#x27;content&#x27;)    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col-md-8 col-md-offset-2&quot;&gt;                &lt;a class=&quot;btn btn-primary&quot;  href=&quot;&#123;&#123;route(&#x27;articles.create&#x27;)&#125;&#125;&quot; style=&quot;margin-bottom: 8px;&quot;&gt;创建文章&lt;/a&gt;                @foreach($articles as $article)                    &lt;a href=&quot;&#123;&#123;route(&#x27;articles.edit&#x27;,$article-&gt;id)&#125;&#125;&quot; style=&quot;display: block;text-decoration: none;&quot;&gt;                        &lt;div class=&quot;panel panel-default&quot;&gt;                            &lt;div class=&quot;panel-heading&quot;&gt;&#123;&#123;$article-&gt;title&#125;&#125;&lt;/div&gt;                            &lt;div class=&quot;panel-body&quot;&gt;                                &#123;&#123;$article-&gt;content&#125;&#125;                            &lt;/div&gt;                            &lt;div class=&quot;panel-footer&quot;&gt;                                &lt;form action=&quot;&#123;&#123;route(&#x27;articles.destroy&#x27;,$article-&gt;id)&#125;&#125;&quot; method=&quot;post&quot; style=&quot;display: block;&quot;&gt;                                    &#123;&#123; csrf_field() &#125;&#125;                                    &#123;&#123; method_field(&#x27;DELETE&#x27;) &#125;&#125;                                    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;删除&lt;/button&gt;                                &lt;/form&gt;                            &lt;/div&gt;                        &lt;/div&gt;                    &lt;/a&gt;                @endforeach            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;@endsection\n\n好了，现在创建文章和显示文章列表都有了，现在我们做修改文章和删除文章\n修改文章创建edit()方法\npublic function edit($id)&#123;    $article = Article::findOrFail($id);    return view(&#x27;articles.edit&#x27;,compact(&#x27;article&#x27;));&#125;\n\n更新文章创建update()方法\npublic function update(Request $request,$id)&#123;    $this-&gt;validate($request,[        &#x27;title&#x27;=&gt;&#x27;required|max:50&#x27;    ]);    $article=Article::findOrFail($id);    $article-&gt;update([        &#x27;title&#x27;=&gt;$request-&gt;title,        &#x27;content&#x27;=&gt;$request-&gt;articleContent,    ]);    return redirect()-&gt;route(&#x27;articles.index&#x27;);&#125;\n\n\n\n修改articles.edit视图\n @extends(&#x27;layouts.app&#x27;)@section(&#x27;content&#x27;)    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col-md-10 col-md-offset-1&quot;&gt;                &lt;form action=&quot;&#123;&#123;route(&#x27;articles.update&#x27;,$article-&gt;id)&#125;&#125;&quot;  method=&quot;post&quot; role=&quot;form&quot;&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &#123;&#123; csrf_field() &#125;&#125;                        &#123;&#123; method_field(&#x27;PATCH&#x27;) &#125;&#125;                        &lt;label for=&quot;title&quot;&gt;标题&lt;/label&gt;                        &lt;input class=&quot;form-control&quot; type=&quot;text&quot; name=&quot;title&quot; value=&quot;&#123;&#123;$article-&gt;title&#125;&#125;&quot;&gt;                        &lt;label for=&quot;name&quot;&gt;文本框&lt;/label&gt;                        &lt;textarea class=&quot;form-control&quot; name=&quot;articleContent&quot; rows=&quot;3&quot;&gt;&#123;&#123;$article-&gt;content&#125;&#125;&lt;/textarea&gt;                        &lt;button class=&quot;btn btn-primary&quot; style=&quot;margin-top:8px; float: right&quot; type=&quot;submit&quot;&gt;提交&lt;/button&gt;                    &lt;/div&gt;                &lt;/form&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    @endsection\n\n删除文章现在满足了修改更新，下面我们来写删除。修改destroy()\npublic function destroy($id)&#123;    $article=Article::findOrfail($id);    $article-&gt;delete();    return back();&#125;\n\n现在我们已经满足了，博客的基本的增、删、改、查、的功能，现在我们添加中间件，只有登录后才能使用博客。\n添加登录中间件打开 ArticlesController.php 控制器，创建__construct() 方法。\npublic function __construct()&#123;    $this-&gt;middleware(&#x27;auth&#x27;);&#125;\n\n打开app/Http/Middleware/RedirectIfAuthenticated.php\n&lt;?phpnamespace App\\Http\\Middleware;use Closure;use Illuminate\\Support\\Facades\\Auth;class RedirectIfAuthenticated&#123;    /**     * Handle an incoming request.     *     * @param  \\Illuminate\\Http\\Request  $request     * @param  \\Closure  $next     * @param  string|null  $guard     * @return mixed     */    public function handle($request, Closure $next, $guard = null)    &#123;        if (Auth::guard($guard)-&gt;check()) &#123;            return redirect(&#x27;/articles&#x27;);//修改重定向到文章列表页        &#125;        return $next($request);    &#125;&#125;\n\n打开app/Http/Controllers/Auth/LoginController.php\n&lt;?phpnamespace App\\Http\\Controllers\\Auth;use App\\Http\\Controllers\\Controller;use Illuminate\\Foundation\\Auth\\AuthenticatesUsers;class LoginController extends Controller&#123;    /*    |--------------------------------------------------------------------------    | Login Controller    |--------------------------------------------------------------------------    |    | This controller handles authenticating users for the application and    | redirecting them to your home screen. The controller uses a trait    | to conveniently provide its functionality to your applications.    |    */    use AuthenticatesUsers;    /**     * Where to redirect users after login.     *     * @var string     */    protected $redirectTo = &#x27;/articles&#x27;;//修改重定向到文章页    /**     * Create a new controller instance.     *     * @return void     */    public function __construct()    &#123;        $this-&gt;middleware(&#x27;guest&#x27;)-&gt;except(&#x27;logout&#x27;);    &#125;&#125;\n\n修改welcome.blade.php视图\n&lt;!doctype html&gt;&lt;html lang=&quot;&#123;&#123; config(&#x27;app.locale&#x27;) &#125;&#125;&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;Laravel&lt;/title&gt;        &lt;!-- Fonts --&gt;        &lt;link href=&quot;https://fonts.googleapis.com/css?family=Raleway:100,600&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;        &lt;!-- Styles --&gt;        &lt;style&gt;            html, body &#123;                background-color: #fff;                color: #636b6f;                font-family: &#x27;Raleway&#x27;, sans-serif;                font-weight: 100;                height: 100vh;                margin: 0;            &#125;            .full-height &#123;                height: 100vh;            &#125;            .flex-center &#123;                align-items: center;                display: flex;                justify-content: center;            &#125;            .position-ref &#123;                position: relative;            &#125;            .top-right &#123;                position: absolute;                right: 10px;                top: 18px;            &#125;            .content &#123;                text-align: center;            &#125;            .title &#123;                font-size: 84px;            &#125;            .links &gt; a &#123;                color: #636b6f;                padding: 0 25px;                font-size: 12px;                font-weight: 600;                letter-spacing: .1rem;                text-decoration: none;                text-transform: uppercase;            &#125;            .m-b-md &#123;                margin-bottom: 30px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;flex-center position-ref full-height&quot;&gt;            @if (Route::has(&#x27;login&#x27;))                &lt;div class=&quot;top-right links&quot;&gt;                    @if (Auth::check())                        &lt;a href=&quot;&#123;&#123; route(&#x27;articles.index&#x27;) &#125;&#125;&quot;&gt;博客&lt;/a&gt;                    @else                        &lt;a href=&quot;&#123;&#123; url(&#x27;/login&#x27;) &#125;&#125;&quot;&gt;登录&lt;/a&gt;                        &lt;a href=&quot;&#123;&#123; url(&#x27;/register&#x27;) &#125;&#125;&quot;&gt;注册&lt;/a&gt;                    @endif                &lt;/div&gt;            @endif            &lt;div class=&quot;content&quot;&gt;                &lt;div class=&quot;title m-b-md&quot;&gt;                    迷你博客 &lt;a href=&quot;&#123;&#123;route(&#x27;articles.index&#x27;)&#125;&#125;&quot;&gt;点我进入&lt;/a&gt;                &lt;/div&gt;                &lt;div class=&quot;links&quot;&gt;                    &lt;a href=&quot;https://laravel.com/docs&quot;&gt;Documentation&lt;/a&gt;                    &lt;a href=&quot;https://laracasts.com&quot;&gt;Laracasts&lt;/a&gt;                    &lt;a href=&quot;https://laravel-news.com&quot;&gt;News&lt;/a&gt;                    &lt;a href=&quot;https://forge.laravel.com&quot;&gt;Forge&lt;/a&gt;                    &lt;a href=&quot;https://github.com/laravel/laravel&quot;&gt;GitHub&lt;/a&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\n\n文章控制器完整代码&lt;?phpnamespace App\\Http\\Controllers;use App\\Article;//因为这段代码中用到了Eloquent 模型的构造器用法，所以需要引入我们之前创建的模型。use Illuminate\\Http\\Request;class ArticlesController extends Controller&#123;    public function __construct()    &#123;        $this-&gt;middleware(&#x27;auth&#x27;);    &#125;    public function create()&#123;        return view(&#x27;articles.create&#x27;);    &#125;    public function edit($id)&#123;        $article = Article::findOrFail($id);        return view(&#x27;articles.edit&#x27;,compact(&#x27;article&#x27;));    &#125;    public function index()&#123;        $articles = Article::orderBy(&#x27;created_at&#x27;,&#x27;desc&#x27;)-&gt;get();        return view(&#x27;articles.index&#x27;,compact(&#x27;articles&#x27;));    &#125;    public function store(Request $request)&#123;        $this-&gt;validate($request,[            &#x27;title&#x27;=&gt;&#x27;required|max:50&#x27;,//在收到表单传过来的数据时，可以先对表单数据进行验证        ]);        $article = Article::create([            &#x27;title&#x27; =&gt; $request-&gt;title,            &#x27;content&#x27; =&gt; $request-&gt;articleContent,        ]);        return redirect()-&gt;route(&#x27;articles.index&#x27;);//最后完成文章的创建，然后重定向到文章列表页    &#125;    public function update(Request $request,$id)&#123;        $this-&gt;validate($request,[            &#x27;title&#x27;=&gt;&#x27;required|max:50&#x27;        ]);        $article=Article::findOrFail($id);        $article-&gt;update([            &#x27;title&#x27;=&gt;$request-&gt;title,            &#x27;content&#x27;=&gt;$request-&gt;articleContent,        ]);        return redirect()-&gt;route(&#x27;articles.index&#x27;);    &#125;    public function destroy($id)&#123;        $article=Article::findOrfail($id);        $article-&gt;delete();        return back();    &#125;&#125;\n\nDEMO项目地址https://coding.net/u/Colorful_Ghost/p/Laravel-Miniblog/git\n","categories":["教程"],"tags":["Laravel","博客"]},{"title":"vue-element-admin 后台管理框架集成","url":"/2018/09/04/vue-element-admin%20%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90/","content":"必要的准备工作\nES6特性的基本了解 \nVue2.0框架 \n关于Vue实例的生命周期 \n关于Vue实例的生命周期created和mounted的区别\nVuejs中关于computed、methods、watch的区别\nVue2 组件间通信全方案\n\n\nelement-ui \naxios 请求接口\naxios post方式传递参数，请求参数格式化\n\n\nvue-router 官方路由组件\nMock.js 拦截ajax请求生成假数据\nvue-element-admin官方文档\n\n环境的搭建Node.js和Git的安装\nhttps://nodejs.org/en/  （开代理访问速度更快）\nhttps://git-scm.com/downloads Windows下的Git工具\n\nVSCode自带的集成终端powershell在npm全局安装需要管理员权限\n踩坑后的解决方案：https://segmentfault.com/q/1010000009166404\n\nVSCode插件推荐及配置相关必备插件\nESLint 插件化的 javascript 代码检测工具\nPrettier 代码美化插件\nVetur vue 插件 语法高亮、智能感知、Emmet 等\nGitlens git 日志插件\n\n推荐插件\nBetter Comments可配置的代码注释插件 \nAuto Rename Tag自动重命名 HTML/XML 标签\nOpen in browser在默认浏览器打开 HTML 文件\nPath Intellisense自动路劲补全\nPolacode代码截图\nSetting Sync同步 VScode 插件配置\nVSCode Great Icons文档类型图标\nDracula Official暗色系主题\nBracket Pair Colorizer让括号拥有独立的颜色，易于区分\n\n推荐的插件配置&#123;  &quot;editor.fontSize&quot;: 20,  &quot;editor.multiCursorModifier&quot;: &quot;ctrlCmd&quot;,  &quot;editor.snippetSuggestions&quot;: &quot;top&quot;,  &quot;explorer.confirmDelete&quot;: false,  &quot;files.associations&quot;: &#123;    &quot;*.tpl&quot;: &quot;html&quot;  &#125;,  &quot;editor.wordWrap&quot;: &quot;on&quot;,  &quot;editor.renderIndentGuides&quot;: true,  &quot;emmet.triggerExpansionOnTab&quot;: true,  &quot;gitlens.advanced.messages&quot;: &#123;    &quot;suppressCommitHasNoPreviousCommitWarning&quot;: false,    &quot;suppressCommitNotFoundWarning&quot;: false,    &quot;suppressFileNotUnderSourceControlWarning&quot;: false,    &quot;suppressGitVersionWarning&quot;: false,    &quot;suppressLineUncommittedWarning&quot;: false,    &quot;suppressNoRepositoryWarning&quot;: false,    &quot;suppressResultsExplorerNotice&quot;: false,    &quot;suppressShowKeyBindingsNotice&quot;: true,    &quot;suppressUpdateNotice&quot;: false,    &quot;suppressWelcomeNotice&quot;: true  &#125;,  // &quot;editor.formatOnSave&quot;: true,  &quot;[javascript]&quot;: &#123;    &quot;editor.formatOnSave&quot;: true  &#125;,  &quot;html.format.enable&quot;: false,  &quot;gitlens.gitExplorer.files.layout&quot;: &quot;tree&quot;,  &quot;git.enableSmartCommit&quot;: true,  &quot;emmet.includeLanguages&quot;: &#123;    &quot;markdown&quot;: &quot;html&quot;  &#125;,  &quot;emmet.excludeLanguages&quot;: [&quot;&quot;],  &quot;eslint.enable&quot;: false,  &quot;workbench.startupEditor&quot;: &quot;newUntitledFile&quot;,  // &quot;prettier.spaceBeforeFunctionParen&quot;: true,  &quot;editor.tabSize&quot;: 2,  &quot;eslint.autoFixOnSave&quot;: true,  &quot;git.autofetch&quot;: true,  &quot;editor.formatOnPaste&quot;: false,  &quot;prettier.tabWidth&quot;: 2,  &quot;prettier.singleQuote&quot;: true,  &quot;prettier.trailingComma&quot;: &quot;none&quot;,  &quot;prettier.semi&quot;: false,  &quot;prettier.useTabs&quot;: false,  &quot;vetur.format.defaultFormatter.js&quot;: &quot;prettier&quot;,  &quot;vetur.format.defaultFormatterOptions&quot;: &#123;    &quot;js-beautify-html&quot;: &#123;      &quot;wrap_attributes&quot;: &quot;force-aligned&quot;    &#125;  &#125;,  &quot;editor.insertSpaces&quot;: true,  &quot;editor.detectIndentation&quot;: true,  &quot;eslint.validate&quot;: [    &quot;javascript&quot;,    &quot;javascriptreact&quot;,    &quot;html&quot;,    &quot;vue&quot;,    &#123;      &quot;language&quot;: &quot;vue&quot;,      &quot;autoFix&quot;: true    &#125;  ],  &quot;eslint.options&quot;: &#123;    &quot;plugins&quot;: [&quot;html&quot;]  &#125;,  &quot;editor.formatOnSave&quot;: true,  // &quot;prettier.javascriptEnable&quot;: [  //     &quot;javascript&quot;,  //     &quot;javascriptreact&quot;  // ],  &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,  &quot;emmet.syntaxProfiles&quot;: &#123;    &quot;vue-html&quot;: &quot;html&quot;,    &quot;vue&quot;: &quot;html&quot;  &#125;,  &quot;gitlens.keymap&quot;: &quot;alternate&quot;,  &quot;explorer.confirmDragAndDrop&quot;: false,  &quot;search.location&quot;: &quot;sidebar&quot;,  &quot;files.exclude&quot;: &#123;    &quot;**/.git&quot;: true,    &quot;**/.svn&quot;: true,    &quot;**/.hg&quot;: true,    &quot;**/CVS&quot;: true,    &quot;**/.DS_Store&quot;: true,    &quot;**/bower_components&quot;: true,    &quot;**/jspm_packages&quot;: true  &#125;,  &quot;extensions.autoUpdate&quot;: true,  &quot;gitlens.historyExplorer.enabled&quot;: true,  &quot;markdown.preview.breaks&quot;: true&#125;\n把以上配置放入VScode IDE 下 .vscode/settings.json工作区设置里\n准备开始搬砖补充关于路径@占位符：webpack.base.conf.js\nmodule.exports = &#123;  context: path.resolve(__dirname, &#x27;../&#x27;),  entry: &#123;    app: &#x27;./src/main.js&#x27;  &#125;,  output: &#123;    path: config.build.assetsRoot,    filename: &#x27;[name].js&#x27;,    publicPath: process.env.NODE_ENV === &#x27;production&#x27;      ? config.build.assetsPublicPath      : config.dev.assetsPublicPath  &#125;,  resolve: &#123;    extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;],    alias: &#123;      &#x27;@&#x27;: resolve(&#x27;src&#x27;),    &#125;  &#125;\n\nwebpack配置的路径,@占位符表示src。\n所有的功能实现都从路由开始路由和侧边栏是组织起一个后台应用的关键骨架\n&#123;  path: &#x27;/getClassReport&#x27;,  component: Layout,  redirect: &#x27;/permission/index&#x27;, //重定向地址，在面包屑中点击会重定向去的地址  hidden: true, // 不在侧边栏线上  alwaysShow: true, //一直显示根路由  meta: &#123; roles: [&#x27;admin&#x27;,&#x27;editor&#x27;] &#125;, //你可以在根路由设置权限，这样它下面所以的子路由都继承了这个权限  children: [&#123;    path: &#x27;index&#x27;,    component: ()=&gt;import(&#x27;permission/index&#x27;),    name: &#x27;permission&#x27;,    meta: &#123;      title: &#x27;permission&#x27;,      icon: &#x27;lock&#x27;, //图标      role: [&#x27;admin&#x27;,&#x27;editor&#x27;], //或者你可以给每一个子路由设置自己的权限      noCache: true // 不会被 &lt;keep-alive&gt; 缓存    &#125;  &#125;]&#125;\n\n关于keep-alive：是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n使用Mock数据进行开发基础路由侧边栏的配置@/router/index.vue\n&#123;  path: &#x27;/pi&#x27;,  component: Layout,  children: [    &#123;      path: &#x27;index&#x27;,      component: () =&gt; import(&#x27;@/views/pi/index&#x27;),      name: &#x27;raspberrypi&#x27;,      meta: &#123; title: &#x27;Raspberry Pi&#x27;, icon: &#x27;raspberrypi&#x27; &#125;    &#125;  ]&#125;\n\n创建API请求方法在 @api 文件夹下创建API \n@/api/pi.js\nimport request from &#x27;@/utils/request&#x27;export function getGPIOStatus() &#123;  return request(&#123;    url: &#x27;/pi/getGPIOStatus&#x27;,    method: &#x27;get&#x27;  &#125;)&#125;\n\n使用Mock.js拦截请求在@/mock/index.js添加拦截规则\nimport raspberryPiAPI from &#x27;./pi&#x27; //导入创建的APIMock.mock(/\\/pi\\/getGPIOStatus/, &#x27;get&#x27;, raspberryPiAPI.getGPIOStatus)\n\n添加对拦截接口的Mock数据进行生成新建Mock生成规则文件@/mock/pi.js \nimport Mock from &#x27;mockjs&#x27;const GPIOSize = 14const GPIO = []for (let item = 0; item &lt; GPIOSize; item++) &#123;  GPIO.push(Mock.mock(    &#123;      &#x27;gpio&#x27;: &#x27;@increment&#x27;,       &#x27;name&#x27;: Mock.Random.csentence(1, 3),      &#x27;switch&#x27;: Mock.Random.bool(3, 20, true)    &#125;  ))&#125;export default &#123;  getGPIOStatus: () =&gt; &#123;    return &#123;        //把生成组装好的Mock数据导出      total: GPIO.length,      items: GPIO    &#125;  &#125;&#125;\n\n创建路由所指向对应的业务组件@/views/pi/index.vue\n&lt;template&gt;  &lt;div class=&quot;tab-container&quot;&gt;    &lt;el-table :data=&quot;tabData&quot;  //表格绑定tabData数据              border // 一些样式调整              fit              highlight-current-row              style=&quot;width:100%&quot;&gt;      &lt;el-table-column align=&quot;center&quot; // 表格文字居中                       prop=&quot;gpio&quot;  //tabData.gpio 字段                       label=&quot;GPIO&quot;&gt; // 标签      &lt;/el-table-column&gt;      &lt;el-table-column align=&quot;center&quot;                       prop=&quot;name&quot;                       label=&quot;作用&quot;&gt;      &lt;/el-table-column&gt;      &lt;el-table-column align=&quot;center&quot;                       prop=&quot;switch&quot;                       label=&quot;状态&quot;&gt;                  &lt;template slot-scope=&quot;scope&quot;&gt;   https://segmentfault.com/a/1190000012996217              &lt;!--通过（scope.row）拿到当前行数据--&gt;          &lt;el-tag v-if=scope.row.switch  //当检查改行数据switch状态来渲染标签                  type=&quot;success&quot;&gt;打开状态&lt;/el-tag&gt;          &lt;el-tag v-else                  type=&quot;danger&quot;&gt;关闭状态&lt;/el-tag&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column align=&quot;center&quot;                       prop=&quot;switch&quot;                       label=&quot;开关&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;           &lt;el-switch v-model=&quot;scope.row.switch&quot;                     active-color=&quot;#13ce66&quot; //激活状态的颜色                     inactive-color=&quot;#ff4949&quot; //闭合状态的颜色                     @change=&#x27;change($event,scope.$index,scope)&#x27;&gt;&lt;/el-switch&gt;\t\t\t\t\t// change事件 传入当前事件的值，和插槽索引，和插槽详细参数        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    //导入请求APIimport &#123; getGPIOStatus &#125; from &#x27;@/api/pi&#x27;export default &#123;  data() &#123;    return &#123;      tabData: null    &#125;  &#125;,  created() &#123;      //在创建钩子上调用请求接口方法    this.getGPIOData()  &#125;,  methods: &#123;      //在参数改变时候在控制台打印日志    change: function($callback, index, scope) &#123;        // $callback在改变事件时候el-switch的状态，index索引      this.$log.debug(&#x27;switch callback状态&#x27;, $callback, index, scope)    &#125;,    getGPIOData() &#123;      getGPIOStatus().then(response =&gt; &#123;        this.tabData = response.data.items      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.tab-container &#123;  margin: 20px;&#125;&lt;/style&gt;\n\n关于slot-scope：vue原生slot-scope 的值将被用作一个临时变量名,可以接收父组件传过来的值, 而在element中的table对slot-scope的值封装成了一个大的对象,对象里面有属性row(行),column(列),$index(索引),store,所以我们可以通过scope.row拿到对应的值。\n使用真实接口进行开发基础路由侧边栏的配置@/router/index.vue\n&#123;  path: &#x27;/getClassReport&#x27;,   component: Layout,  children: [    &#123;      path: &#x27;index&#x27;,      component: () =&gt; import(&#x27;@/views/getClassReport/index&#x27;),      name: &#x27;getClassReport&#x27;,      meta: &#123; title: &#x27;获取班级报告&#x27;, icon: &#x27;example&#x27; &#125;    &#125;  ]&#125;\n\n每个页面或者模块特定的业务组件则会写在当前 views 下面。如：@/views/article/components/xxx.vue\n创建和视图对应的API在 @api 文件夹下创建API\n@api/getClassReport.js\n//vue-element-admin 封装的请求方法import request from &#x27;@/utils/request&#x27;import qs from &#x27;qs&#x27;export function getClassReport(hwId, classId) &#123;    //格式化传参 原因查看准备工作4-1  const data = qs.stringify(&#123;    hwId,    classId  &#125;)  return request(&#123;    url:      &#x27;/homework_middle_customer_service/homeworkReportService/getClassReport&#x27;,    method: &#x27;post&#x27;,    data  &#125;)&#125;\n\n\n\n创建路由所指向对应的业务组件在views下创建目录和@views/getClassReport/index.vue父组件\n&lt;template&gt;  &lt;el-container&gt; // Container 布局容器 方便快速搭建页面的基本结构    &lt;el-header&gt;      &lt;h2 class=&quot;hwTitle&quot;          v-if=&quot;classData!=null&quot;&gt;&#123;&#123;classData.hwTitle&#125;&#125;&lt;/h2&gt;// 在classData不为null的时候渲染dom    &lt;/el-header&gt;    &lt;el-main&gt;      &lt;el-row&gt;          // 类似于 BootStrap的栅格布局 如果不使用md xs lg sm属性 可以使用:span属性        &lt;el-col :md=&quot;12&quot;                 :xs=&quot;24&quot;&gt;            // 自定义子组件 echarts 饼图  自定义属性把classData的返回值传递给子组件          &lt;pieChart :classReportData=&#x27;classData&#x27;&gt;&lt;/pieChart&gt;        &lt;/el-col&gt;        &lt;el-col :md=&quot;12&quot;                :xs=&quot;24&quot;&gt;          &lt;el-card&gt;              //循环classData Map里的key和value 打印出来            &lt;div v-for=&quot;(val,key) in classData&quot;                  :key=&quot;key&quot;&gt;              &#123;&#123;key&#125;&#125;----&#123;&#123;val&#125;&#125;&lt;/div&gt;          &lt;/el-card&gt;        &lt;/el-col&gt;      &lt;/el-row&gt;      &lt;el-footer&gt;          // 自定义子组件输入框 自定义属性在子组件组件里创建         &lt;getReportInput @put-hw-param=&#x27;getClassReportData&#x27;&gt;&lt;/getReportInput&gt;       &lt;/el-footer&gt;    &lt;/el-main&gt;  &lt;/el-container&gt;&lt;/template&gt;&lt;script&gt; //导入组件                               import pieChart from &#x27;./PieChart&#x27;import getReportInput from &#x27;./input&#x27;import &#123; getClassReport &#125; from &#x27;@/api/getClassReport&#x27; // 班级报告API//http://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/module#export-default-%E5%91%BD%E4%BB%A4export default &#123;    // name相当于组件的相当于一个全局 ID，https://cn.vuejs.org/v2/api/#name  name: &#x27;getClassReport&#x27;,  components: &#123; pieChart, getReportInput &#125;,  data() &#123;      // 不使用return包裹的数据会在项目的全局可见，会造成变量污染       // 使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。    return &#123;      classData: null    &#125;  &#125;,    //created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）。  created() &#123;      //默认传参    this.getClassReportData(      &#x27;4ac6aa86-4373-4c50-873e-9922edcce57d&#x27;,      &#x27;1500000200030607345&#x27;    )  &#125;,  methods: &#123;     //如果传参为空直接return    getClassReportData(hwId, classId) &#123;      if (hwId == null || classId == null) &#123;        return      &#125;        // 请求接口      return getClassReport(hwId, classId).then(response =&gt; &#123;          //如果返回值不等于200弹出错误消息提示框        if (response.data.code !== 200) &#123;          this.$message(response.data.info)          return        &#125;        //在全局配置了日志组件vuejs-logger        this.$log.debug(&#x27;response&#x27;, response.data)          //把请求到的数据放入data里        this.classData = response.data.result      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;// 全局的 @/style 放置一下全局公用的样式，每一个页面的样式就写在当前 views下面，加上scoped 或者命名空间，避免造成全局的样式污染。&lt;style scoped&gt;h2.hwTitle &#123;  text-align: center;  color: lightsalmon;&#125;&lt;/style&gt;\n\n创建输入框子组件@views/getClassReport/input.vue\n&lt;template&gt;  &lt;el-row :gutter=&quot;10&quot; // gutter\t栅格间隔          justify=&quot;center&quot; // flex 布局下的水平排列方式           type=&quot;flex&quot;&gt;    &lt;el-col :span=&quot;4&quot;&gt;      &lt;el-input v-model=&quot;hwId&quot;                placeholder=&quot;作业Id&quot;                change=&quot;setHwId&quot;&gt;&lt;/el-input&gt;    &lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;      &lt;el-input v-model=&quot;classId&quot;                placeholder=&quot;班级Id&quot;                change=&quot;setClassId&quot;&gt;&lt;/el-input&gt;    &lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;      &lt;el-button type=&quot;primary&quot;                 @click=&quot;classReportEvent&quot;&gt;请求数据&lt;/el-button&gt;//点击触发事件    &lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;getReportInput&#x27;,  data() &#123;    return &#123;      hwId: &#x27;&#x27;,      classId: &#x27;&#x27;    &#125;  &#125;,  methods: &#123;    classReportEvent() &#123;        //通过$emit 实现子组件向父组件通信 属性名称为put-hw-param，把hwId classId传递给父组件      this.$emit(&#x27;put-hw-param&#x27;, this.hwId, this.classId)    &#125;  &#125;&#125;&lt;/script&gt;\n\n创建echarts饼图组件@views/getClassReport/PieChart.vue\n关于Echarts 使用方法需要到http://echarts.baidu.com/充电 ，我也是搬砖而已。\n&lt;template&gt;  &lt;div :class=&quot;className&quot;       :style=&quot;&#123;height:height,width:width&#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import echarts from &#x27;echarts&#x27;require(&#x27;echarts/theme/macarons&#x27;) // echarts themeimport &#123; debounce &#125; from &#x27;@/utils&#x27;export default &#123;  props: &#123;      // 从父组件接收的值    classReportData: &#123;      default: null    &#125;,    className: &#123;      type: String,      default: &#x27;chart&#x27;    &#125;,    width: &#123;      type: String,      default: &#x27;100%&#x27;    &#125;,    height: &#123;      type: String,      default: &#x27;400px&#x27;    &#125;  &#125;,  watch: &#123;      //监测classReportData返回值是否有变动，有变动的初始化echarts图形    classReportData() &#123;      this.initChart()    &#125;  &#125;,  data() &#123;    return &#123;      chart: null    &#125;  &#125;,  mounted() &#123;    this.__resizeHanlder = debounce(() =&gt; &#123;      if (this.chart) &#123;        this.chart.resize()      &#125;    &#125;, 100)    window.addEventListener(&#x27;resize&#x27;, this.__resizeHanlder)  &#125;,  beforeDestroy() &#123;    if (!this.chart) &#123;      return    &#125;    window.removeEventListener(&#x27;resize&#x27;, this.__resizeHanlder)    this.chart.dispose()    this.chart = null  &#125;,  methods: &#123;    initChart() &#123;      this.chart = echarts.init(this.$el, &#x27;macarons&#x27;)      this.chart.setOption(&#123;        tooltip: &#123;          trigger: &#x27;item&#x27;,          formatter: &#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;        &#125;,        legend: &#123;          left: &#x27;center&#x27;,          bottom: &#x27;10&#x27;,          data: [&#x27;fullCount&#x27;, &#x27;goodCount&#x27;, &#x27;passCount&#x27;, &#x27;unPassCount&#x27;]        &#125;,        calculable: true,        series: [          &#123;            name: &#x27;班级报告&#x27;,            type: &#x27;pie&#x27;,            roseType: &#x27;radius&#x27;,            radius: [15, 95],            center: [&#x27;50%&#x27;, &#x27;38%&#x27;],            data: [              &#123; value: this.classReportData.fullCount, name: &#x27;fullCount&#x27; &#125;,              &#123; value: this.classReportData.goodCount, name: &#x27;goodCount&#x27; &#125;,              &#123; value: this.classReportData.passCount, name: &#x27;passCount&#x27; &#125;,              &#123; value: this.classReportData.unPassCount, name: &#x27;unPassCount&#x27; &#125;            ],            animationEasing: &#x27;cubicInOut&#x27;,            animationDuration: 2600          &#125;        ]      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;\n\n进阶扩展例： 安装日志组件https://www.npmjs.com/package/vuejs-logger\n在终端输入安装\nnpm install vuejs-logger --save-exact\n\n把日志组件设置成全局组件\n在main.js引入日志组件\nimport VueLogger from &#x27;vuejs-logger&#x27;const options = &#123;    isEnabled: true,    logLevel : isProduction ? &#x27;error&#x27; : &#x27;debug&#x27;,    stringifyArguments : false,    showLogLevel : true,    showMethodName : true,    separator: &#x27;|&#x27;,    showConsoleColors: true&#125;//查配置插件注入到全局方法Vue.use(VueLogger, options)\n\n在其他组件就可以很简单的使用它来打印一些对象和变量了\nthis.$log.debug(&#x27;response&#x27;, response.data)\n\n\n关于一些第三方组件模块的引用，查看文档内的相关说明。\n关于icon图标自定义 阿里”爸爸”的庞大的图标库：http://iconfont.cn/\n在图标库里搜索你想要的图标，下载该图标SVG文件，然后扔进@/icons\n食用方法：\n&lt;svg-icon icon-class=&quot;password&quot; /&gt;\n比Font Awesome图标字体库使用舒服多了。\n构建打包这里打包只是在本地打包 ，没有使用CI进行打包构建。\n修改打包环境在/config目录下配置dev.env.js 开发环境地址 或新增其他环境文件\nmodule.exports = &#123;  NODE_ENV: &#x27;&quot;development&quot;&#x27;,  ENV_CONFIG: &#x27;&quot;dev&quot;&#x27;,  BASE_API: &#x27;&quot;https://api-dev&quot;&#x27; //替换你的API环境的地址&#125;\n\n打包命令# 打包正式环境npm run build:prod# 打包测试环境npm run build:sit# 打包开发环境npm run build:dev\n\n然后在项目根目录下/dist目录生成打包后的静态文件。\n然后扔到你的CDN或者nginx服务器里就万事大吉了。\n","categories":["Vue"],"tags":["Vue","后台管理"]},{"title":"爬取iciba.com的翻译数据","url":"/2018/03/24/%E7%88%AC%E5%8F%96iciba-com%E7%9A%84%E7%BF%BB%E8%AF%91%E6%95%B0%E6%8D%AE/","content":"ICIBA接口调研访问ICIBA网站接口默认传参URLhttp://www.iciba.com/index.php?callback=jQuery190037237954499612624_1521877397217&amp;a=getWordMean&amp;c=search&amp;list=1,2,3,4,5,8,9,10,12,13,14,15,18,21,22,24,3003,3004,3005&amp;word=test&amp;_=1521877397218\n接口传参意义，分析传参含义\ncallback：iciba JQuery回调函数形式返回到该网站\n\na=getWordMean：获取单词参数\n\nc=search：查询单词参数\n\nword：传递所需要的单词\n\nlist=1,2,3,4,5,8,9,10,12,13,14,15,18,21,22,24,3003,3004,3005\n\n1参数显示基础单词信息，路径：JSON.baesInfo\n2参数显示单词分析信息，路径：JSON.sameAnalysis\n3柯林斯高阶英汉双解学习词典，路径：JSON.collins\n4英英词典，路径：JSON.ee_mean\n5行业词典，路径：JSON.trade_means\n8双语例句，路径：JSON.sentence\n9（1,9组合会出现网络释义，路径JSON.netmean），路径：JSON.baesInfo\n10权威例句，路径：JSON.auth_sentence\n12释义变形（此参数并没有显示在页面里），路径：JSON.synonym\n14词组和句型，路径：JSON.phrase\n15词根词缀，路径：JSON.stems_affixes\n18百度百科，路径：JSON.encyclopedia\n21四级真题，路径：JSON.cetFour\n3003词性、中英例句、翻译并未在页面展示 ，路径：JSON.bidec\n3005句式用法，路径：JSON.jushi\n如果list不传参或者输入0默认显示所有信息\n\n\n\n产品需求数据\n输入单词：JSON.baesInfo.word_name\n音标+翻译：JSON.baesInfo.symbols\n变形：JSON.baesInfo.exchange\n双语例句：JSON.sentence\n句式用法：JSON.jushi\n权威例句：JSON.auth_sentence\n\n此时list参数传参值为：1,6,8,10,3005 ，减少无用参数，优化请求速度。\nhttp://www.iciba.com/index.php?&amp;a=getWordMean&amp;c=search&amp;list=1,6,8,10,3005&amp;word=test\n数据库设计数据表名：dic_auth_sentence注释：权威例句表\n\n\n\n字段\n数据类型\n注释\n类型\n\n\n\nid\nint(11)\n权威例句id\n主键\n\n\ncontent\nvarchar(255)\n内容\n\n\n\nlink\nvarchar(255)\n相关链接\n\n\n\nsource\nvarchar(50)\n来源\n\n\n\nword_id\nint(11)\n单词id\n\n\n\n数据表名：dic_base_info注释：音标表\n\n\n\n字段\n数据类型\n注释\n类型\n\n\n\nid\nint(11)\n单词id\n主键\n\n\nword\nvarchar(128)\n单词\n\n\n\nph_en\nvarchar(255)\n英  音标\n\n\n\nph_am\nvarchar(255)\n美  音标\n\n\n\nph_en_mp3\nvarchar(255)\n英  音标mp3\n\n\n\nph_am_mp3\nvarchar(255)\n美  音标mp3\n\n\n\ncreate_time\ndatetime\n创建时间\n\n\n\n数据表名：dic_base_info_test注释： 音标表\n\n\n\n字段\n数据类型\n注释\n类型\n\n\n\nid\nint(11)\n单词id\n主键\n\n\nword\nvarchar(128)\n单词\n\n\n\nph_en\nvarchar(255)\n英  音标\n\n\n\nph_am\nvarchar(255)\n美  音标\n\n\n\nph_en_mp3\nvarchar(255)\n英  音标mp3\n\n\n\nph_am_mp3\nvarchar(255)\n美  音标mp3\n\n\n\ncreate_time\ndatetime\n创建时间\n\n\n\n数据表名：dic_exchange注释： 单词变形表\n\n\n\n字段\n数据类型\n注释\n类型\n\n\n\nword_id\nint(11)\n单词id\n主键\n\n\nword_pl\nvarchar(128)\n复数\n\n\n\nword_past\nvarchar(128)\n过去式\n\n\n\nword_done\nvarchar(128)\n过去分词\n\n\n\nword_ing\nvarchar(128)\n现在分词\n\n\n\nword_third\nvarchar(128)\n第三人称单数\n\n\n\nword_er\nvarchar(128)\n比较级\n\n\n\nword_est\nvarchar(128)\n最高级\n\n\n\nword_prep\nvarchar(128)\n代词\n\n\n\nword_adv\nvarchar(128)\n副词\n\n\n\nword_verb\nvarchar(128)\n动词\n\n\n\nword_noun\nvarchar(128)\n名词\n\n\n\nword_adj\nvarchar(128)\n形容词\n\n\n\nword_conn\nvarchar(128)\n系连词\n\n\n\n数据表名：dic_jushi注释： 句式用法表\n\n\n\n字段\n数据类型\n注释\n类型\n\n\n\nid\nint(11)\n句式用法id\n主键\n\n\nword_id\nint(11)\n单词id\n\n\n\nenglish\nvarchar(255)\n英语例句\n\n\n\nchinese\nvarchar(255)\n中文例句\n\n\n\n数据表名：dic_parts注释：翻译表\n\n\n\n字段\n数据类型\n注释\n类型\n\n\n\nid\nint(11)\n词性id\n主键\n\n\nword_id\nint(11)\n单词id\n\n\n\npart\nvarchar(50)\n词性\n\n\n\nmeans\nvarchar(255)\n释义\n\n\n\n数据表名：dic_sentence注释：双语例句表\n\n\n\n字段\n数据类型\n注释\n类型\n\n\n\nid\nint(11)\n例句id\n主键\n\n\nword_id\nint(11)\n单词id\n\n\n\nenglish\nvarchar(255)\n例句英文\n\n\n\nchinese\nvarchar(255)\n例句中文\n\n\n\n数据表名：dic_temp_word注释： 跑批单词\n\n\n\n字段\n数据类型\n注释\n类型\n\n\n\nid\nint(11)\n单词id\n主键\n\n\nword\nvarchar(255)\n单词\n\n\n\nis_set\ntinyint(1) unsigned zerofill\n0未跑1跑过\n\n\n\nJAVA实现方案\nHTTPUtils：请求接口，获取资源\n\nString url = &quot;http://www.iciba.com/index.php&amp;a=getWordMean&amp;c=search&amp;list=1,6,8,10,3005&amp;word=&quot;;\t\t\t//get请求翻译API            try &#123;                wordMean = java.net.URLEncoder.encode(wordMean, &quot;UTF-8&quot;);//把特殊字符转码            &#125; catch (UnsupportedEncodingException e) &#123;                e.printStackTrace();            &#125;            final HttpResponse response = WS.url(url + wordMean).get();//get请求url            final String res = WS.getResponseAsString(response);\n\n\nFastjson：解析获取到的JSON，找到所需要数据的路径\n\n       JSONObject jsonObject = JSON.parseObject(res);            int errno = (int) JSONPath.eval(jsonObject, &quot;$.errno&quot;);            if (errno == 404) &#123;                 return FAIL;            &#125;JSONObject symbols = (JSONObject) JSONPath.eval(jsonObject, &quot;$.baesInfo.symbols[0]&quot;);//音标+mp3JSONObject exchange = (JSONObject) JSONPath.eval(jsonObject, &quot;$.baesInfo.exchange&quot;);//变形单词ArrayList&lt;JSONObject&gt; sentences = (ArrayList&lt;JSONObject&gt;) JSONPath.eval(jsonObject, &quot;$.sentence[0:2]&quot;);//双语例句ArrayList&lt;JSONObject&gt; jushi = (ArrayList&lt;JSONObject&gt;) JSONPath.eval(jsonObject, &quot;$.jushi[0:2]&quot;);//句式语法ArrayList&lt;JSONObject&gt; authSentence = (ArrayList&lt;JSONObject&gt;) JSONPath.eval(jsonObject, &quot;$.auth_sentence[0:2]&quot;);//权威例句String wordName = (String) JSONPath.eval(jsonObject, &quot;$.baesInfo.word_name&quot;);//单词名\n\n\n遍历获取到的数据并存入MYSQL\n\n            int wordId;            if (wordMeanMapper.checkWord(wordName) != null) &#123;                ReturnT.FAIL.setMsg(&quot;单词已经存在&quot;);                return FAIL;            &#125;            wordMeanMapper.insertWord(wordName);            wordId = (int) wordMeanMapper.checkWord(wordName).get(&quot;id&quot;);            try &#123;                if (symbols != null) &#123;//没有音标一定没有该单词的释义，直接取得单词的网络翻译                    //发音音标                    String ph_en = symbols.getString(&quot;ph_en&quot;);// 英 音标                    String ph_am = symbols.getString(&quot;ph_am&quot;);//美 音标//                String ph_other = symbols.getString(&quot;ph_other&quot;);                    String ph_en_mp3 = symbols.getString(&quot;ph_en_mp3&quot;);//英 音标发音                    String ph_am_mp3 = symbols.getString(&quot;ph_am_mp3&quot;);//美 音标发音                    String ph_tts_mp3 = symbols.getString(&quot;ph_tts_mp3&quot;);//tts原生 发音                    wordMeanMapper.insertSymbols(wordId, ph_en, ph_am, ph_en_mp3, ph_am_mp3, ph_tts_mp3);                    //变形词汇                    String reg = &quot;[\\\\[\\\\]\\&quot;]&quot;;                    String word_pl = exchange.getString(&quot;word_pl&quot;).replaceAll(reg, &quot;&quot;);                    String word_third = exchange.getString(&quot;word_third&quot;).replaceAll(reg, &quot;&quot;);                    String word_past = exchange.getString(&quot;word_past&quot;).replaceAll(reg, &quot;&quot;);                    String word_done = exchange.getString(&quot;word_done&quot;).replaceAll(reg, &quot;&quot;);                    String word_ing = exchange.getString(&quot;word_ing&quot;).replaceAll(reg, &quot;&quot;);                    String word_er = exchange.getString(&quot;word_er&quot;).replaceAll(reg, &quot;&quot;);                    String word_est = exchange.getString(&quot;word_est&quot;).replaceAll(reg, &quot;&quot;);                    String word_prep = exchange.getString(&quot;word_prep&quot;).replaceAll(reg, &quot;&quot;);                    String word_adv = exchange.getString(&quot;word_adv&quot;).replaceAll(reg, &quot;&quot;);                    String word_verb = exchange.getString(&quot;word_verb&quot;).replaceAll(reg, &quot;&quot;);                    String word_noun = exchange.getString(&quot;word_noun&quot;).replaceAll(reg, &quot;&quot;);                    String word_adj = exchange.getString(&quot;word_adj&quot;).replaceAll(reg, &quot;&quot;);                    String word_conn = exchange.getString(&quot;word_conn&quot;).replaceAll(reg, &quot;&quot;);                    wordMeanMapper.insertExchange(wordId, word_pl, word_past, word_done, word_ing, word_third, word_er, word_est, word_prep, word_adv, word_verb, word_noun, word_adj, word_conn                    );                    //词性翻译                    JSONArray parts = symbols.getJSONArray(&quot;parts&quot;);                    for (Object partObj : parts) &#123;                        JSONObject partJSONObject = (JSONObject) partObj;                        String means = partJSONObject.getString(&quot;means&quot;);                        means = means.replaceAll(reg, &quot;&quot;);                        String part = partJSONObject.getString(&quot;part&quot;);                        wordMeanMapper.insertParts(part, means, wordId);                    &#125;                &#125; else &#123;                    String translateResult = (String) JSONPath.eval(jsonObject, &quot;$.baesInfo.translate_result&quot;);                    wordMeanMapper.updateTranslateResult(wordMean, translateResult);                &#125;            &#125; catch (Exception e) &#123;                e.printStackTrace();                return FAIL;            &#125;            //双语例句            for (JSONObject sentence : sentences) &#123;                String networkEN = sentence.getString(&quot;Network_en&quot;);                String networkCN = sentence.getString(&quot;Network_cn&quot;);                String mp3 = sentence.getString(&quot;tts_mp3&quot;);                String mp3Size = sentence.getString(&quot;tts_size&quot;);                wordMeanMapper.insertSentence(networkEN, networkCN, mp3, mp3Size, wordId);            &#125;            //句式用法            for (JSONObject jushiObj : jushi) &#123;                String english = jushiObj.getString(&quot;english&quot;);                String chinese = jushiObj.getString(&quot;chinese&quot;);                String mp3 = jushiObj.getString(&quot;mp3&quot;);                wordMeanMapper.insertJushi(english, chinese, mp3, wordId);            &#125;            //权威例句            for (JSONObject authSentenceObj : authSentence) &#123;                String content = authSentenceObj.getString(&quot;content&quot;);                String link = authSentenceObj.getString(&quot;link&quot;);                String source = authSentenceObj.getString(&quot;source&quot;);                String mp3 = authSentenceObj.getString(&quot;tts_mp3&quot;);                String mp3Size = authSentenceObj.getString(&quot;tts_size&quot;);                wordMeanMapper.insertAuthSentence(content, link, source, mp3, mp3Size, wordId);            &#125;\n\nMapper   @Insert(&quot;INSERT INTO fanyi_word(word)VALUES(#&#123;word&#125;)&quot;)//插入传入的单词   int insertWord(String word);   @Insert(&quot;UPDATE fanyi_word SET translate_result=#&#123;translate_result&#125; WHERE word=#&#123;word&#125;&quot;)   int updateTranslateResult(@Param(&quot;word&quot;)String word,@Param(&quot;translate_result&quot;)String translateResult);//网络翻译结果   @Insert(&quot;INSERT INTO fanyi_sentence(english,chinese,tts_mp3,tts_size,word_id) VALUES(#&#123;english&#125;,#&#123;chinese&#125;,#&#123;tts_mp3&#125;,#&#123;tts_size&#125;,#&#123;word_id&#125;)&quot;)//插入例句   int insertSentence(@Param(&quot;english&quot;) String english,                      @Param(&quot;chinese&quot;) String chinese,                      @Param(&quot;tts_mp3&quot;) String tts_mp3,                      @Param(&quot;tts_size&quot;) String tts_size,                      @Param(&quot;word_id&quot;) int wordId);   @Insert(&quot;INSERT INTO fanyi_auth_sentence(content,link,source,tts_mp3,tts_size,word_id)VALUES(#&#123;content&#125;,#&#123;link&#125;,#&#123;source&#125;,#&#123;tts_mp3&#125;,#&#123;tts_size&#125;,#&#123;word_id&#125;)&quot;)//权威例句   int insertAuthSentence(@Param(&quot;content&quot;) String content,                          @Param(&quot;link&quot;) String link,                          @Param(&quot;source&quot;) String source,                          @Param(&quot;tts_mp3&quot;) String tts_mp3,                          @Param(&quot;tts_size&quot;) String tts_size,                          @Param(&quot;word_id&quot;) int wordId);   @Insert(&quot;INSERT INTO fanyi_jushi(english,chinese,mp3,word_id)VALUES(#&#123;english&#125;,#&#123;chinese&#125;,#&#123;mp3&#125;,#&#123;word_id&#125;)&quot;)//句式   int insertJushi(@Param(&quot;english&quot;) String english,                   @Param(&quot;chinese&quot;) String chinese,                   @Param(&quot;mp3&quot;) String mp3,                   @Param(&quot;word_id&quot;) int wordId);   @Insert(&quot;INSERT INTO fanyi_symbols(word_id,ph_en,ph_am,ph_en_mp3,ph_am_mp3,ph_tts_mp3)VALUES(#&#123;word_id&#125;,#&#123;ph_en&#125;,#&#123;ph_am&#125;,#&#123;ph_en_mp3&#125;,#&#123;ph_am_mp3&#125;,#&#123;ph_tts_mp3&#125;)&quot;)//音标资源   int insertSymbols(@Param(&quot;word_id&quot;) int wordId,                     @Param(&quot;ph_en&quot;) String ph_en,                     @Param(&quot;ph_am&quot;) String ph_am,                     @Param(&quot;ph_en_mp3&quot;) String ph_en_mp3,                     @Param(&quot;ph_am_mp3&quot;) String ph_am_mp3,                     @Param(&quot;ph_tts_mp3&quot;) String ph_tts_mp3);   @Insert(&quot;INSERT INTO fanyi_parts(part,means,word_id)VALUES(#&#123;part&#125;,#&#123;means&#125;,#&#123;word_id&#125;)&quot;)//翻译+词性   int insertParts(@Param(&quot;part&quot;)String part,                   @Param(&quot;means&quot;)String means,                   @Param(&quot;word_id&quot;)int wordId);   @Insert(&quot;INSERT INTO fanyi_exchange (`word_id`, `word_pl`, `word_past`, `word_done`, `word_ing`, `word_third`, `word_er`, `word_est`, `word_prep`, `word_adv`, `word_verb`, `word_noun`, `word_adj`, `word_conn`)&quot; +           &quot;VALUES(#&#123;word_id&#125;,#&#123;word_pl&#125;,#&#123;word_past&#125;,#&#123;word_done&#125;,#&#123;word_ing&#125;,#&#123;word_third&#125;,#&#123;word_er&#125;,#&#123;word_est&#125;,#&#123;word_prep&#125;,#&#123;word_adv&#125;,#&#123;word_verb&#125;,#&#123;word_noun&#125;,#&#123;word_adj&#125;,#&#123;word_conn&#125;)&quot;)//单词变形   int insertExchange(@Param(&quot;word_id&quot;)int wordId,                      @Param(&quot;word_pl&quot;)String word_pl,                      @Param(&quot;word_past&quot;)String word_past,                      @Param(&quot;word_done&quot;)String word_done,                      @Param(&quot;word_ing&quot;)String word_ing,                      @Param(&quot;word_third&quot;)String word_third,                      @Param(&quot;word_er&quot;)String word_er,                      @Param(&quot;word_est&quot;)String word_est,                      @Param(&quot;word_prep&quot;)String word_prep,                      @Param(&quot;word_adv&quot;)String word_adv,                      @Param(&quot;word_verb&quot;)String word_verb,                      @Param(&quot;word_noun&quot;)String word_noun,                      @Param(&quot;word_adj&quot;)String word_adj,                      @Param(&quot;word_conn&quot;)String word_conn);   @Select(&quot;SELECT word,id FROM fanyi_word WHERE word = #&#123;word&#125;&quot;)//检查单词是否存在   Map checkWord(String word);\n\nPython    实现方案import sysimport ioimport jsonimport jsonpathfrom utils import get_redis_connfrom examples.iciba.crawler import Crawlerfrom utils import mysql_utilsys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=&#x27;utf8&#x27;)  # 为了xxl-job输出不出现乱码，格式化为utf8host = &#x27;http://www.iciba.com/index.php?&amp;a=getWordMean&amp;c=search&amp;list=1,6,8,10,3005&amp;word=&#x27;waiting_set = &#x27;iciba:seeds:to_crawl&#x27;seeds_all = &#x27;iciba:seeds:all&#x27;info_set = &#x27;iciba:info:wordmsg&#x27;# Not considering concurrent securitycommon_crawler = Crawler()def init_db():    redis_client = get_redis_conn(db=2)    return redis_clientdef get_info(word):    &quot;&quot;&quot;get user info&quot;&quot;&quot;    url = host + word    html = common_crawler.get(url)    if not html:        return    py_obj = json.loads(html.encode(&#x27;utf8&#x27;))    try:        word_name = jsonpath.jsonpath(py_obj, &quot;$.baesInfo.word_name&quot;)  # 单词名称        exchanges = jsonpath.jsonpath(py_obj, &quot;$.baesInfo.exchange&quot;)  # 变形单词        symbols = jsonpath.jsonpath(py_obj, &quot;$.baesInfo.symbols[0]&quot;)  # 音标+mp3        parts = jsonpath.jsonpath(py_obj, &quot;$.baesInfo.symbols[0].parts&quot;)  # 翻译词性        translate_result = jsonpath.jsonpath(py_obj, &quot;$.baesInfo.translate_result&quot;)  # 网络翻译        is_errno = jsonpath.jsonpath(py_obj, &quot;$.errno&quot;)  # 单词是否存在        auth_sentence = jsonpath.jsonpath(py_obj, &quot;$.auth_sentence[:3]&quot;)  # 权威例句        jushi = jsonpath.jsonpath(py_obj, &quot;$.jushi[:3]&quot;)  # 句式语法        sentence = jsonpath.jsonpath(py_obj, &quot;$.sentence[:3]&quot;)  # 双语例句        if translate_result or is_errno[0] == 404:  # 单词是否错误翻译，使用网络翻译，返回单词id            print(&#x27;单词不存在，单词出错&#x27;)            return        word_id = mysql_util.insert_word(word_name[0])        if not word_id: #如果单词已经存在则直接跳出            return        for symbol in symbols: #发音音标            mysql_util.insert_symbols(word_id, symbol[&#x27;ph_en&#x27;], symbol[&#x27;ph_am&#x27;], symbol[&#x27;ph_en_mp3&#x27;],                                      symbol[&#x27;ph_am_mp3&#x27;], symbol[&#x27;ph_tts_mp3&#x27;])        for part in parts[0]: # 词性翻译            mysql_util.insert_parts(word_id, part[&#x27;part&#x27;], part[&#x27;means&#x27;])        if  auth_sentence:            for i in auth_sentence:  # 单词权威例句                mysql_util.insert_auth_sentence(i[&#x27;content&#x27;], i[&#x27;link&#x27;], i[&#x27;source&#x27;], i[&#x27;tts_mp3&#x27;], i[&#x27;tts_size&#x27;], word_id)        if  jushi:            for i in jushi:  # 句式                mysql_util.insert_jushi(i[&#x27;english&#x27;], i[&#x27;chinese&#x27;], i[&#x27;mp3&#x27;], word_id)        if  sentence:            for i in sentence:  # 双语例句                mysql_util.insert_sentence(i[&#x27;Network_en&#x27;], i[&#x27;Network_cn&#x27;], i[&#x27;tts_mp3&#x27;], i[&#x27;tts_size&#x27;], word_id)        for exchange in exchanges: # 单词变形 把空数组赋值为NULL，并存入            for key,value in exchange.items():                if not value:                    exchange[key]=None            mysql_util.insert_exchange(word_id, exchange[&#x27;word_pl&#x27;], exchange[&#x27;word_past&#x27;], exchange[&#x27;word_done&#x27;],                                       exchange[&#x27;word_ing&#x27;], exchange[&#x27;word_third&#x27;], exchange[&#x27;word_er&#x27;],                                       exchange[&#x27;word_est&#x27;], exchange[&#x27;word_prep&#x27;], exchange[&#x27;word_adv&#x27;],                                       exchange[&#x27;word_verb&#x27;], exchange[&#x27;word_noun&#x27;], exchange[&#x27;word_adj&#x27;],                                       exchange[&#x27;word_conn&#x27;])    except Exception as e:        print(e)        return    return htmldef start():    redis_client = init_db()    while not redis_client.scard(waiting_set):        # block if there is no seed in waitting_set        print(&quot;%s里的单词全部跑完，等待下次跑批&quot; % waiting_set)        return    # fetch seeds from waitting_set    word = redis_client.spop(waiting_set).decode()    print(&quot;正在获取%s单词数据中……&quot; % word)    word_data = get_info(word)    redis_client.hset(info_set, word, word_data)    # redis_client.sadd(info_set, user)    print(&quot;%s单词已经保存&quot; % word)def xxl_job(): # xxl_job调用的函数  waiting_set的单词从Redis里获取然后跑入到MySQL    redis_conn = init_db()    while True:        if not redis_conn.scard(waiting_set):            print(&quot;所有单词已经跑完，等待下次跑批&quot;)            break        start()if __name__ == &#x27;__main__&#x27;:    init_seeds = [&#x27;test&#x27;] # 直接运行测试数据    redis_conn = init_db()    redis_conn.sadd(waiting_set, *init_seeds)    redis_conn.sadd(seeds_all, *init_seeds)    while True:        start()\n\nMySQL_util.pyfrom config.settings import (MYSQL_DATABASE, MYSQL_HOST, MYSQL_PASSWORD, MYSQL_PROT, MYSQL_USER, MYSQL_CHARSET)import pymysql.cursorsdef get_conn_mysql():    connection = pymysql.connect(host=MYSQL_HOST,                                 user=MYSQL_USER,                                 port=MYSQL_PROT,                                 passwd=MYSQL_PASSWORD,                                 db=MYSQL_DATABASE,                                 charset=MYSQL_CHARSET)    return connectiondef insert_word(word):    try:        connection = get_conn_mysql()        cursor = connection.cursor()        insert_word = &quot;INSERT INTO `fanyi_word` (`id`,`word`) VALUES (%s, %s)&quot;        check_word = &quot;SELECT word FROM `fanyi_word` WHERE word=%s LIMIT 1&quot;        result = cursor.execute(check_word, word)  # 检查表内是否有该单词        if not result:            cursor.execute(insert_word, (cursor.lastrowid, word))            connection.commit()            return cursor.lastrowid        else:            return    finally:        connection.close()def insert_symbols(word_id, ph_en, ph_am, ph_en_mp3, ph_am_mp3, ph_tts_mp3):    try:        connection = get_conn_mysql()        cursor = connection.cursor()        insert_symbols = &quot;INSERT INTO `fanyi_symbols` (`word_id`, `ph_en`, `ph_am`, `ph_en_mp3`, `ph_am_mp3`, `ph_tts_mp3`) VALUES (%s, %s, %s, %s, %s, %s)&quot;        cursor.execute(insert_symbols, (word_id, ph_en, ph_am, ph_en_mp3, ph_am_mp3, ph_tts_mp3))        connection.commit()    finally:        connection.close()def insert_parts(word_id, part, means):    try:        connection = get_conn_mysql()        cursor = connection.cursor()        insert_parts = &quot;INSERT INTO `fanyi_parts` (`part`, `means`, `word_id`) VALUES (%s, %s, %s)&quot;        means_str = &#x27;,&#x27;.join(means)        cursor.execute(insert_parts, (part, means_str, word_id))        connection.commit()    finally:        connection.close()def insert_sentence(english, chinese, tts_mp3, tts_size, word_id):    try:        connection = get_conn_mysql()        cursor = connection.cursor()        insert_sentence = &quot;INSERT INTO `fanyi_sentence` (`english`, `chinese`, `tts_mp3`, `tts_size`, `word_id`) VALUES (%s, %s, %s,%s, %s)&quot;        cursor.execute(insert_sentence, (english, chinese, tts_mp3, tts_size, word_id))        connection.commit()    finally:        connection.close()def insert_jushi(english, chinese, mp3, word_id):    try:        connection = get_conn_mysql()        cursor = connection.cursor()        insert_jushi = &quot;INSERT INTO `fanyi_jushi` (`english`, `chinese`, `mp3`, `word_id`) VALUES ( %s, %s,%s, %s)&quot;        cursor.execute(insert_jushi, (english, chinese, mp3, word_id))        connection.commit()    finally:        connection.close()def insert_auth_sentence(content, link, source, tts_mp3, tts_size, word_id):    try:        connection = get_conn_mysql()        cursor = connection.cursor()        insert_auth_sentence = &quot;INSERT INTO `fanyi_auth_sentence` (`content`, `link`, `source`, `tts_mp3`, `tts_size`, `word_id`) VALUES (%s, %s,%s, %s,%s,%s)&quot;        cursor.execute(insert_auth_sentence, (content, link, source, tts_mp3, tts_size, word_id))        connection.commit()    finally:        connection.close()def insert_exchange(word_id, word_pl, word_past, word_done, word_ing, word_third, word_er, word_est, word_prep,                    word_adv, word_verb, word_noun, word_adj, word_conn):    try:        connection = get_conn_mysql()        cursor = connection.cursor()        insert_exchange = &quot;INSERT INTO `fanyi_exchange` (`word_id`, `word_pl`, `word_past`, `word_done`, `word_ing`, `word_third`, `word_er`, `word_est`, `word_prep`, `word_adv`, `word_verb`, `word_noun`, `word_adj`, `word_conn`) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)&quot;        cursor.execute(insert_exchange, (        word_id, word_pl, word_past, word_done, word_ing, word_third, word_er, word_est, word_prep, word_adv, word_verb,        word_noun, word_adj, word_conn))        connection.commit()    finally:        connection.close()\n\n使用Spring Boot 对Redis缓存单词package com.xxl.job.executor.mvc.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.data.redis.RedisConnectionFailureException;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;@Controller@EnableAutoConfigurationpublic class IndexController &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @RequestMapping(value = &quot;/redis/addWord/&#123;value&#125;&quot;, method = RequestMethod.GET)    @ResponseBody    public String redisTest(@PathVariable String value) &#123;        String waitingSet = &quot;iciba:seeds:to_crawl&quot;;        String seedsAll = &quot;iciba:seeds:all&quot;;        try &#123;            stringRedisTemplate.opsForSet().add(waitingSet, value);            stringRedisTemplate.opsForSet().add(seedsAll, value);            return String.format(&quot;%s已经成功添加！&quot;, value);        &#125;catch (RedisConnectionFailureException e)&#123;            e.printStackTrace();            return &quot;redis连接失败&quot;;        &#125;    &#125;&#125;\n\n使用xxl-job调度中心执行\nhttps://github.com/xuxueli/xxl-job\n\n\nJava ：在xxl-job里运行模式选择Bean模式使用Java版本在调度中心设置JobHandler执行器名称和，并执行器内添加注解@JobHandler(value=&quot;demoJobHandler&quot;)\nPython：使用GLUE（Python）模式\n\n注：如果在Linux下Python有多个版本，可以在com.xxl.job.core.glue.GlueTypeEnum下修改脚本执行前缀，如：GLUE_PYTHON(&quot;GLUE(Python)&quot;, true, &quot;python3.6&quot;, &quot;.py&quot;)\nGLUE(Python)模式代码：\n#!/usr/bin/python3.6# -*- coding: UTF-8 -*-import timeimport sysprint(sys.stdout)sys.path.append(&#x27;F:\\\\workspace\\\\haipproxy-0.1&#x27;) # Windows下的项目路径，Linux下需要更换from examples.iciba.iciba_spider import xxl_jobxxl_job()exit(0)\n\n使用haipproxy匿名代理爬取\nhttps://github.com/SpiderClub/haipproxy\n\n这个开源项目爬取一些免费的代理网站，获取代理IP地址，然后对这些IP进行筛选打分，打分策略针对各个IP请求成功率、响应速度、最近验证时间和是否匿名这四个维度。\n这个项目的详细文档在github上的wiki里，我在配置一些Python环境和依赖踩了不少坑，为了用这个项目去特意学习了Python和Redis…\n","categories":["教程"],"tags":["爬虫","iciba"]},{"title":"Confluence安装破解记录","url":"/2022/02/18/Confluence%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3%E8%AE%B0%E5%BD%95/","content":"安装破解记录\n环境准备：Linux、JDK8+、MySQL\nConfluence安装包：https://www.atlassian.com/software/confluence/download-archives\n在服务器上wget下载链接完成后给文件执行权限chmod +x atlassian-confluence-x.x.x-x64.bin\n./atlassian-confluence-x.x.x-x64.bin  根据提示一路回车和确认默认安装\n安装完成后访问http://IP:8090 确认安装成功\n破解准备：https://gitee.com/pengzhile/atlassian-agent 下载wget release到服务器中解压。\n到服务器刚刚解压运行这个破解jar查看使用方法 java -jar atlassian-agent.jar -h\n他返回了export JAVA_OPTS=&quot;-javaagent:...&quot;复制好备用。\n根据官方文档 确认到/etc/init.d/confluence 是运行文件 vim查看启动脚本。\n确认启动路径为：/opt/atlassian/confluence/bin/start-confluence.sh 后使用vim编辑\nfind export 在上面添加刚刚复制好的 export JAVA_OPTS=&quot;-javaagent:/home/atlassian-agent-v1.3.1/atlassian-agent.jar $&#123;JAVA_OPTS&#125;&quot;\nsudo /etc/init.d/confluence restart重启Confluence\n输入ps aux|grep agent 查看confluence  java进程，确认被载入atlassian-agent.jar\n复制网站中的服务器ID准备生成Confluence激活码，到服务器中atlassian-agent.jar的目录\njava -jar atlassian-agent.jar -p conf -m admin@iacg.moe -n Ghost -o Ghost -s xxxx-LASW-X5SS-CID5 \n输入上面生成的激活码到网站激活根据提示和自身需求下一步。\n到数据库步骤如果选择MySQL需要根据提示到官网下载驱动\n到驱动下载页面选择平台无关解压出jar放入confluence的lib路径（我是下载MySQL8.0）\nsudo /etc/init.d/confluence restart 成功后刷新页面看到MySQL选项可以输入\n在创建数据库名为confluence的数据库字符集用utf8mb4_bin\n在mysql链接参数中加入jdbc:mysql://localhost/confluence?sessionVariables=tx_isolation=&#39;READ-COMMITTED’\n下一步就是根据自身需求去配置了，配置全部完成后准备ngnix代理下。\nConfluence安装完成，剩下的就是对空间和网站的配置。\n\n破解插件\n去查找新应用寻找插件、安装完成后到管理应用里去复制你刚下载应用密钥\n进入atlassian-agent.jar 的目录下把你刚刚复制的应用密钥粘贴到下面-p参数后\n java -jar atlassian-agent.jar -p com.mxgraph.confluence.plugins.diagramly -m admin@iacg.moe -n Ghost -o AnHuiWater -s BM78-LASW-X5SS-CID5\n把生成的激活码黏贴到应用密钥下下面的许可证关键字的框框里完成激活。\n\n","tags":["Confluence","安装"]}]